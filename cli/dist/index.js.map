{"version":3,"sources":["../src/index.ts"],"names":["cartridge","Cartridge","builder","build","vRam","VRam","initializeRandomly","mmu","Mmu","bios","WorkingRam","IOMemory","OamMemory","ZeroPageRam","screen","setPixel","cpu","Cpu","device","Device","Gpu","insertCartridge","turnOn","pixelToOutChar","color","tileToString","tile","map","r","join","printEnd","console","log","bgP","toString","forEach","i","getTileDataFromTable1","some","c","getTileDataFromTable2","TOTAL","opCode","readByte","registers","pc","getInstructionLabel","tickCycle","e"],"mappings":"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","sourcesContent":["import {\n  Device,\n  Cpu,\n  Gpu,\n  Mmu,\n  bios,\n  IOMemory,\n  VRam,\n  WorkingRam,\n  ZeroPageRam,\n  OamMemory,\n  PixelColor,\n  Tile,\n  Cartridge\n} from \"@gebby/core\";\nimport { range, flatMap } from \"lodash\";\n\nconst cartridge = Cartridge.builder().build();\n\nconst vRam = VRam.initializeRandomly();\n\nconst mmu = new Mmu(\n  bios,\n  new WorkingRam(),\n  vRam,\n  new IOMemory(),\n  new OamMemory(),\n  new ZeroPageRam()\n);\n\nconst screen = {\n  setPixel(): void {\n    // TODO:\n  }\n};\n\nconst cpu = new Cpu();\n\nconst device = new Device(cpu, new Gpu(mmu, screen), mmu);\ndevice.insertCartridge(cartridge);\ndevice.turnOn();\n\n// process.stdout.write instead of console.log\n// Clear: console.log('\\033c')\n// Alt: console.log('\\033c\\033[3J')\n// Console pixels: console.log('\\u2591', '\\u2592', '\\u2588')\n// light 2591 2592 2593 dark   2588 fully black/solid\n// If running in a black terminal, then that might be reversed i guess?\n\n// See https://nodejs.org/api/stream.html#stream_writable_cork\n// think you can cork then uncork to prevent half scene being rendered\n\n// see also \"process.setImmediate\" for timer\n// process.stdout.write\n\n// See https://www.npmjs.com/package/terminal-kit\n// See comment here about using the half block and bk and fg colors:\n// https://github.com/cronvel/terminal-kit/blob/HEAD/doc/high-level.md#ref.drawImage\n\nconst pixelToOutChar = (color: PixelColor): string => {\n  switch (color) {\n    case 3:\n      return \"\\u2588\";\n    case 2:\n      return \"\\u2592\";\n    case 1:\n      return \"\\u2591\";\n  }\n  return \" \";\n};\n\nconst tileToString = (tile: Tile): string =>\n  tile.map(r => r.map(pixelToOutChar).join(\"\")).join(\"\\n\");\n\nconst printEnd = (): void => {\n  console.log(\"BG & window palette\", mmu.bgP.toString(2));\n\n  console.log(\"Table 1 tiles:\");\n  range(0, 255).forEach(i => {\n    const tile = vRam.getTileDataFromTable1(i);\n    if (flatMap(tile).some(c => c !== 0)) {\n      console.log(i + \")\");\n      console.log(tileToString(tile));\n    }\n  });\n\n  console.log(\"Table 2 tiles:\");\n  range(0, 255).forEach(i => {\n    const tile = vRam.getTileDataFromTable2(i);\n    if (flatMap(tile).some(c => c !== 0)) {\n      console.log(i + \")\");\n      console.log(tileToString(tile));\n    }\n  });\n\n  console.log(\"Background map 1:\");\n  // console.log(\n  //   vRam.bgMap1\n  //     .map(row =>\n  //       [...row]\n  //         .map(i => tileToString(vRam.getTileDataFromTable1(i)))\n  //         .reduce(\n  //           (accu: string, tile: string): string =>\n  //             zip(accu.split(\"\\n\"), tile.split(\"\\n\"))\n  //               .map(([accuRow, newRow]) => (accuRow || \"\") + newRow)\n  //               .join(\"\\n\"),\n  //           repeat(\"\\n\", 7)\n  //         )\n  //     )\n  //     .join(\"\\n\")\n  // );\n};\n\nconst TOTAL = 500000;\nfor (let i = 0; i < TOTAL; i++) {\n  const opCode = mmu.readByte(cpu.registers.pc);\n  console.log(\n    i.toString() + \")\",\n    \"@0x\" + cpu.registers.pc.toString(16),\n    \"0x\" + opCode.toString(16),\n    cpu.getInstructionLabel(opCode)\n  );\n  try {\n    device.tickCycle();\n  } catch (e) {\n    printEnd();\n    throw e;\n  }\n  // if (i % 1000 === 0 || i === (TOTAL - 1)) {\n  //   const values = vRam.values();\n  //   const filled: { [address: number]: number } = {};\n  //   for (let j = 0; j < values.length; j++) {\n  //     if (values[j] !== 0) {\n  //       filled[j] = values[j];\n  //     }\n  //   }\n  //   const addresses = Object.keys(filled).map((k) => parseInt(k)).sort();\n  //   console.log(\"MEM\", addresses.length);\n  //   if (addresses.length > 0) {\n  //     const V_RAM_BASE = 0x8000;\n  //     console.log(\n  //       \"  0x\" + (addresses.sort()[0] + V_RAM_BASE).toString(16),\n  //       \"(0x\" + filled[addresses[0]].toString(16) + \")\",\n  //       \"-\",\n  //       \"0x\" + (addresses[addresses.length - 1] + V_RAM_BASE).toString(16)\n  //     );\n  //   }\n  //   // console.log(\n  //   //   sortBy(\n  //   //     toPairs(filled),\n  //   //     ([address, ]) => address\n  //   //   )\n  //   //     .map(([address, value]) =>\n  //   //       `0x${parseInt(address).toString(16)}: 0x${value.toString(16)}`\n  //   //     )\n  //   //     .join(' ')\n  //   // );\n  // }\n}\n\nprintEnd();\n"],"file":"index.js"}