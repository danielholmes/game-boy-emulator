{"version":3,"sources":["../src/index.ts"],"names":["cartridge","Cartridge","builder","build","Error","vRam","VRam","initializeRandomly","mmu","Mmu","bios","WorkingRam","IOMemory","OamMemory","ZeroPageRam","screen","setPixel","cpu","Cpu","device","Device","Gpu","insertCartridge","turnOn","pixelToOutChar","color","tileToString","tile","map","r","join","printEnd","console","log","bGP","toString","forEach","i","getTileDataFromTable1","some","c","getTileDataFromTable2","bgMap1","row","reduce","accu","split","accuRow","newRow","TOTAL","opCode","readByte","registers","pc","getInstructionLabel","tickCycle","e"],"mappings":"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","sourcesContent":["import {\n  Device,\n  Cpu,\n  Gpu,\n  Mmu,\n  bios,\n  IOMemory,\n  VRam,\n  WorkingRam,\n  ZeroPageRam,\n  OamMemory,\n  PixelColor,\n  Tile,\n  Cartridge,\n  isValidCartridge\n} from \"@gebby/core\";\nimport { range, flatMap, repeat, zip } from \"lodash\";\n\nconst cartridge = Cartridge.builder().build();\nif (!isValidCartridge(cartridge)) {\n  throw new Error(\"Invalid cartridge\");\n}\n\nconst vRam = VRam.initializeRandomly();\n\nconst mmu = new Mmu(\n  bios,\n  new WorkingRam(),\n  vRam,\n  new IOMemory(),\n  new OamMemory(),\n  new ZeroPageRam()\n);\n\nconst screen = {\n  setPixel(): void {\n    // TODO:\n  }\n};\n\nconst cpu = new Cpu();\n\nconst device = new Device(cpu, new Gpu(mmu, screen), mmu);\ndevice.insertCartridge(cartridge);\ndevice.turnOn();\n\n// process.stdout.write instead of console.log\n// Clear: console.log('\\033c')\n// Alt: console.log('\\033c\\033[3J')\n// Console pixels: console.log('\\u2591', '\\u2592', '\\u2588');\n\nconst pixelToOutChar = (color: PixelColor): string => {\n  switch (color) {\n    case 3:\n      return \"\\u2588\";\n    case 2:\n      return \"\\u2592\";\n    case 1:\n      return \"\\u2591\";\n  }\n  return \" \";\n};\n\nconst tileToString = (tile: Tile): string =>\n  tile.map(r => r.map(pixelToOutChar).join(\"\")).join(\"\\n\");\n\nconst printEnd = (): void => {\n  console.log(\"BG & window palette\", mmu.bGP.toString(2));\n\n  console.log(\"Table 1 tiles:\");\n  range(0, 255).forEach(i => {\n    const tile = vRam.getTileDataFromTable1(i);\n    if (flatMap(tile).some(c => c !== 0)) {\n      console.log(i + \")\");\n      console.log(tileToString(tile));\n    }\n  });\n\n  console.log(\"Table 2 tiles:\");\n  range(0, 255).forEach(i => {\n    const tile = vRam.getTileDataFromTable2(i);\n    if (flatMap(tile).some(c => c !== 0)) {\n      console.log(i + \")\");\n      console.log(tileToString(tile));\n    }\n  });\n\n  console.log(\"Background map 1:\");\n  console.log(\n    vRam.bgMap1\n      .map(row =>\n        [...row]\n          .map(i => tileToString(vRam.getTileDataFromTable1(i)))\n          .reduce(\n            (accu: string, tile: string): string =>\n              zip(accu.split(\"\\n\"), tile.split(\"\\n\"))\n                .map(([accuRow, newRow]) => (accuRow || \"\") + newRow)\n                .join(\"\\n\"),\n            repeat(\"\\n\", 7)\n          )\n      )\n      .join(\"\\n\")\n  );\n};\n\nconst TOTAL = 100000;\nfor (let i = 0; i < TOTAL; i++) {\n  const opCode = mmu.readByte(cpu.registers.pc);\n  console.log(\n    i.toString() + \")\",\n    \"@0x\" + cpu.registers.pc.toString(16),\n    \"0x\" + opCode.toString(16),\n    cpu.getInstructionLabel(opCode)\n  );\n  try {\n    device.tickCycle();\n  } catch (e) {\n    printEnd();\n    throw e;\n  }\n  // if (i % 1000 === 0 || i === (TOTAL - 1)) {\n  //   const values = vRam.values();\n  //   const filled: { [address: number]: number } = {};\n  //   for (let j = 0; j < values.length; j++) {\n  //     if (values[j] !== 0) {\n  //       filled[j] = values[j];\n  //     }\n  //   }\n  //   const addresses = Object.keys(filled).map((k) => parseInt(k)).sort();\n  //   console.log(\"MEM\", addresses.length);\n  //   if (addresses.length > 0) {\n  //     const V_RAM_BASE = 0x8000;\n  //     console.log(\n  //       \"  0x\" + (addresses.sort()[0] + V_RAM_BASE).toString(16),\n  //       \"(0x\" + filled[addresses[0]].toString(16) + \")\",\n  //       \"-\",\n  //       \"0x\" + (addresses[addresses.length - 1] + V_RAM_BASE).toString(16)\n  //     );\n  //   }\n  //   // console.log(\n  //   //   sortBy(\n  //   //     toPairs(filled),\n  //   //     ([address, ]) => address\n  //   //   )\n  //   //     .map(([address, value]) =>\n  //   //       `0x${parseInt(address).toString(16)}: 0x${value.toString(16)}`\n  //   //     )\n  //   //     .join(' ')\n  //   // );\n  // }\n}\n\nprintEnd();\n"],"file":"index.js"}