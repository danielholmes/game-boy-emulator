{"version":3,"sources":["../src/types.ts"],"names":["BYTE_BIT_POSITIONS","byteValueToSignedByte","value","binaryToNumber","binary","parseInt","toString","toHex","length","sign","start","end","Math","abs","toLowerCase","undefined","numberToHex","numberToByteHex","numberToWordHex","numberToByteBinary","padStart"],"mappings":";;;;;;;AAAA;;AAaO,IAAMA,kBAAkD,GAAG,CAChE,CADgE,EAEhE,CAFgE,EAGhE,CAHgE,EAIhE,CAJgE,EAKhE,CALgE,EAMhE,CANgE,EAOhE,CAPgE,EAQhE,CARgE,CAA3D;;;AAaA,IAAMC,qBAAqB,GAAG,SAAxBA,qBAAwB,CAACC,KAAD,EAAuC;AAC1E,MAAI,CAACA,KAAK,GAAG,IAAT,MAAmB,CAAvB,EAA0B;AACxB,WAAO,EAAE,CAACA,KAAD,GAAS,IAAX,IAAmB,CAA1B;AACD;;AACD,SAAOA,KAAK,GAAG,IAAf;AACD,CALM;;;;AAOA,IAAMC,cAAc,GAAG,SAAjBA,cAAiB,CAACC,MAAD,EAAwC;AACpE,SAAOC,QAAQ,CAACD,MAAM,CAACE,QAAP,EAAD,EAAoB,CAApB,CAAf;AACD,CAFM;;;;AAIP,IAAMC,KAAK,GAAG,SAARA,KAAQ,CAACL,KAAD,EAAgBM,MAAhB,EAA4C;AACxD,MAAMC,IAAI,GAAGP,KAAK,IAAI,CAAT,GAAa,EAAb,GAAkB,GAA/B;AACA,MAAMQ,KAAK,aAAMD,IAAN,OAAX;AACA,MAAME,GAAG,GAAGC,IAAI,CAACC,GAAL,CAASX,KAAT,EACTI,QADS,CACA,EADA,EAETQ,WAFS,EAAZ;;AAGA,MAAIN,MAAM,KAAKO,SAAf,EAA0B;AACxB,WAAOL,KAAK,GAAGC,GAAf;AACD;;AACD,mBAAUD,KAAV,SAAkB,sBAASC,GAAT,EAAcH,MAAd,EAAsB,GAAtB,CAAlB;AACD,CAVD;;AAYO,IAAMQ,WAAW,GAAG,SAAdA,WAAc,CAACd,KAAD;AAAA,SAA2BK,KAAK,CAACL,KAAD,CAAhC;AAAA,CAApB;;;;AAEA,IAAMe,eAAe,GAAG,SAAlBA,eAAkB,CAACf,KAAD;AAAA,SAA8BK,KAAK,CAACL,KAAD,EAAQ,CAAR,CAAnC;AAAA,CAAxB;;;;AAEA,IAAMgB,eAAe,GAAG,SAAlBA,eAAkB,CAAChB,KAAD;AAAA,SAA8BK,KAAK,CAACL,KAAD,EAAQ,CAAR,CAAnC;AAAA,CAAxB;;;;AAEA,IAAMiB,kBAAkB,GAAG,SAArBA,kBAAqB,CAACjB,KAAD;AAAA,SAChCA,KAAK,CAACI,QAAN,CAAe,CAAf,EAAkBc,QAAlB,CAA2B,CAA3B,EAA8B,GAA9B,CADgC;AAAA,CAA3B","sourcesContent":["import { padStart } from \"lodash\";\n\nexport type PixelColor = 0 | 1 | 2 | 3; // off (white) -> on/black\n\nexport type ColorNumber = 0 | 1 | 2 | 3;\n\nexport type ByteValue = number;\nexport type SignedByteValue = number;\nexport type WordValue = number;\nexport type BitValue = 1 | 0;\n\nexport type ByteBitPosition = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7;\n\nexport const BYTE_BIT_POSITIONS: ReadonlyArray<ByteBitPosition> = [\n  0,\n  1,\n  2,\n  3,\n  4,\n  5,\n  6,\n  7\n];\n\nexport type MemoryAddress = number;\n\nexport const byteValueToSignedByte = (value: WordValue): SignedByteValue => {\n  if ((value & 0x80) !== 0) {\n    return -(~value & 0xff) - 1;\n  }\n  return value & 0xff;\n};\n\nexport const binaryToNumber = (binary: number | string): WordValue => {\n  return parseInt(binary.toString(), 2);\n};\n\nconst toHex = (value: number, length?: number): string => {\n  const sign = value >= 0 ? \"\" : \"-\";\n  const start = `${sign}0x`;\n  const end = Math.abs(value)\n    .toString(16)\n    .toLowerCase();\n  if (length === undefined) {\n    return start + end;\n  }\n  return `${start}${padStart(end, length, \"0\")}`;\n};\n\nexport const numberToHex = (value: number): string => toHex(value);\n\nexport const numberToByteHex = (value: ByteValue): string => toHex(value, 2);\n\nexport const numberToWordHex = (value: WordValue): string => toHex(value, 4);\n\nexport const numberToByteBinary = (value: ByteValue | WordValue): string =>\n  value.toString(2).padStart(8, \"0\");\n"],"file":"types.js"}