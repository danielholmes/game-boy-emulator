{"version":3,"sources":["../src/device.ts"],"names":["CLOCK_SPEED","CLOCK_CYCLES_PER_MACHINE_CYCLE","Device","cpu","gpu","mmu","_isOn","nonUsedMs","cartridge","isOn","Error","console","log","ms","numMachineCycles","Math","floor","numClockCycles","tick","button"],"mappings":";;;;;;;;;;;;;;;;;AAKA;AACA;AACA;AACA,IAAMA,WAAW,GAAG,OAApB;AAEA,IAAMC,8BAA8B,GAAG,CAAvC;;IAEaC,M;;;AAOX,kBAAmBC,GAAnB,EAA6BC,GAA7B,EAAuCC,GAAvC,EAAiD;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAC/C,SAAKF,GAAL,GAAWA,GAAX;AACA,SAAKC,GAAL,GAAWA,GAAX;AACA,SAAKC,GAAL,GAAWA,GAAX;AACA,SAAKC,KAAL,GAAa,KAAb;AACA,SAAKC,SAAL,GAAiB,CAAjB;AACD;;;;oCAMsBC,S,EAA4B;AACjD,UAAI,KAAKC,IAAT,EAAe;AACb,cAAM,IAAIC,KAAJ,mCAAN;AACD;;AACDC,MAAAA,OAAO,CAACC,GAAR,CAAY,kCAAZ,UAAuDJ,SAAvD;AACD;;;sCAE8B;AAC7B,UAAI,KAAKC,IAAT,EAAe;AACb,cAAM,IAAIC,KAAJ,mCAAN;AACD;;AACDC,MAAAA,OAAO,CAACC,GAAR,CAAY,8BAAZ;AACD;;;6BAEqB;AACpB,UAAI,KAAKH,IAAT,EAAe;AACb,cAAM,IAAIC,KAAJ,CAAU,YAAV,CAAN;AACD;;AACD,WAAKJ,KAAL,GAAa,IAAb;AACD;;;8BAEsB;AACrB,UAAI,CAAC,KAAKG,IAAV,EAAgB;AACd,cAAM,IAAIC,KAAJ,CAAU,aAAV,CAAN;AACD;;AACD,WAAKJ,KAAL,GAAa,KAAb;AACD;AAED;;;;;;;yBAIYO,E,EAAkB;AAC5B,UAAI,CAAC,KAAKJ,IAAV,EAAgB;AACd,cAAM,IAAIC,KAAJ,CAAU,gBAAV,CAAN;AACD;;AAED,WAAKH,SAAL,IAAkBM,EAAlB;AACA,UAAMC,gBAAgB,GAAGC,IAAI,CAACC,KAAL,CAAWhB,WAAW,GAAGC,8BAAd,GAA+C,KAA/C,GAAuD,KAAKM,SAAvE,CAAzB;AACA,UAAMU,cAAc,GAAGH,gBAAgB,GAAGb,8BAA1C;AACA,WAAKM,SAAL,IAAmBU,cAAc,GAAGjB,WAApC,CAR4B,CAS5B;;AACA;;;;;;;;;;;;AAWA,WAAKG,GAAL,CAASe,IAAT,CAAc,KAAKb,GAAnB,EAAwBY,cAAxB;AACA,WAAKb,GAAL,CAASc,IAAT,CAAcD,cAAd,EAtB4B,CAuB5B;AACA;AACD;;;gCAEwB;AACvB,WAAKd,GAAL,CAASe,IAAT,CAAc,KAAKb,GAAnB,EAAwB,CAAxB;AACA,WAAKD,GAAL,CAASc,IAAT,CAAc,CAAd,EAFuB,CAGvB;AACA;AACD;;;gCAEkBC,M,EAAsB;AACvCR,MAAAA,OAAO,CAACC,GAAR,CAAY,mBAAZ,EAAiCO,MAAjC;AACD;;;kCAEoBA,M,EAAsB;AACzCR,MAAAA,OAAO,CAACC,GAAR,CAAY,qBAAZ,EAAmCO,MAAnC;AACD;;;wBA5E0B;AACzB,aAAO,KAAKb,KAAZ;AACD","sourcesContent":["import { Gpu } from \"./gpu\";\nimport { Mmu } from \"./memory/mmu\";\nimport { Cpu } from \"./cpu\";\nimport { Cartridge } from \"./cartridge\";\n\n// clock cycles per second 4.19 MHz\n// approx 69,905 clock cycles per frame (60 fps)\n// = approx 17,476 machine cycles per frame\nconst CLOCK_SPEED = 4194304;\n\nconst CLOCK_CYCLES_PER_MACHINE_CYCLE = 4;\n\nexport class Device {\n  private readonly cpu: Cpu;\n  private readonly gpu: Gpu;\n  private readonly mmu: Mmu;\n  private _isOn: boolean;\n  private nonUsedMs: number;\n\n  public constructor(cpu: Cpu, gpu: Gpu, mmu: Mmu) {\n    this.cpu = cpu;\n    this.gpu = gpu;\n    this.mmu = mmu;\n    this._isOn = false;\n    this.nonUsedMs = 0;\n  }\n\n  public get isOn(): boolean {\n    return this._isOn;\n  }\n\n  public insertCartridge(cartridge: Cartridge): void {\n    if (this.isOn) {\n      throw new Error(`Can't insert cartridge while on`);\n    }\n    console.log(\"TODO: Cart insert if not present\", typeof cartridge);\n  }\n\n  public removeCartridge(): void {\n    if (this.isOn) {\n      throw new Error(`Can't remove cartridge while on`);\n    }\n    console.log(\"TODO: Cart remove if present\");\n  }\n\n  public turnOn(): void {\n    if (this.isOn) {\n      throw new Error(\"Already on\");\n    }\n    this._isOn = true;\n  }\n\n  public turnOff(): void {\n    if (!this.isOn) {\n      throw new Error(\"Already off\");\n    }\n    this._isOn = false;\n  }\n\n  /**\n   * Ticks all components in parallel\n   * @param ms\n   */\n  public tick(ms: number): void {\n    if (!this.isOn) {\n      throw new Error(\"Not powered on\");\n    }\n\n    this.nonUsedMs += ms;\n    const numMachineCycles = Math.floor(CLOCK_SPEED / CLOCK_CYCLES_PER_MACHINE_CYCLE * 0.001 * this.nonUsedMs);\n    const numClockCycles = numMachineCycles * CLOCK_CYCLES_PER_MACHINE_CYCLE;\n    this.nonUsedMs -= (numClockCycles / CLOCK_SPEED);\n    // TODO:\n    /*\n      All are running in parallel so should:\n        - each device run for one machine cycle (4 clock cycles)\n        - run for number of machine cycles that will fit into ms\n        - each device should run up to the current cycles, but never beyond\n          - cpu should have everything broken down in to low level operations,\n            including instruction fetch\n            - each instruction then pushes low level ops on to todo stack\n            - low level op can be 4 clock cycles, or 0\n            - when todo stack empty, add fetch instruction low level op\n     */\n    this.cpu.tick(this.mmu, numClockCycles);\n    this.gpu.tick(numClockCycles);\n    // TODO: Timer\n    // TODO: Interrupts\n  }\n\n  public tickCycle(): void {\n    this.cpu.tick(this.mmu, 1);\n    this.gpu.tick(1);\n    // TODO: Timer\n    // TODO: Interrupts\n  }\n\n  public pressButton(button: string): void {\n    console.log(\"TODO: pressButton\", button);\n  }\n\n  public releaseButton(button: string): void {\n    console.log(\"TODO: releaseButton\", button);\n  }\n}\n"],"file":"device.js"}