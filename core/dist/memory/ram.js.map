{"version":3,"sources":["../../src/memory/ram.ts"],"names":["ByteRamStorage","size","raw","Uint8Array","value","Error","address","length","assertValidAddress","subarray","assertByte","ZeroPageRam","storage","readByte","writeByte","WORKING_RAM_SIZE","WorkingRam","values","V_RAM_SIZE","TILE_DATA_TABLE_1_RANGE","TILE_DATA_TABLE_2_RANGE","TILE_DATA_BYTES","TILE_DATA_DIMENSION","TILE_DATA_INDICES","TILE_DATA_PIXEL_INDICES","TILE_DATA_BIT_MASKS","map","i","BG_MAP_1_RANGE","BG_MAP_2_RANGE","BG_MAP_DIMENSION","BG_MAP_INDICES","VRam","startAddress","y","x","index","getTileData","addressRange","endAddress","readBytes","lowerBits","upperBits","lower","upper","getBackgroundMap","getTileMap","vRam","Math","round","random","OamMemory","IOMemory"],"mappings":"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","sourcesContent":["/* eslint-disable */\nimport {\n  ByteValue,\n  MemoryAddress,\n  ReadonlyUint8Array,\n  ColorNumber\n} from \"../types\";\nimport { range, chunk } from \"lodash\";\nimport { toWordHexString } from \"..\";\nimport { toHexString } from \"../utils/numberUtils\";\n\nclass ByteRamStorage {\n  protected readonly raw: ReadonlyUint8Array;\n  private readonly size: number;\n\n  public constructor(size: number) {\n    this.size = size;\n    this.raw = new Uint8Array(this.size);\n  }\n\n  public get values(): ReadonlyUint8Array {\n    return this.raw;\n  }\n\n  private assertValidAddress(value: MemoryAddress): void {\n    if (value < 0x0000 || value >= this.size) {\n      throw new Error(\n        `Address ${toWordHexString(value)} out of range ${toWordHexString(\n          this.size\n        )}`\n      );\n    }\n  }\n\n  public readBytes(address: MemoryAddress, length: number): ReadonlyUint8Array {\n    this.assertValidAddress(address);\n    this.assertValidAddress(address + length - 1);\n    return this.raw.subarray(address, address + length);\n  }\n\n  private assertByte(value: number): void {\n    if (value < 0x00 || value > 0xff) {\n      throw new Error(`Out of bounds byte ${toHexString(value)}`);\n    }\n  }\n\n  public readByte(address: MemoryAddress): ByteValue {\n    this.assertValidAddress(address);\n    return this.raw[address];\n  }\n\n  public writeByte(address: MemoryAddress, value: ByteValue): void {\n    this.assertValidAddress(address);\n    this.assertByte(value);\n    this.raw[address] = value;\n  }\n}\n\nexport class ZeroPageRam {\n  private readonly storage: ByteRamStorage;\n\n  public constructor() {\n    this.storage = new ByteRamStorage(0xff);\n  }\n\n  public readByte(address: MemoryAddress): ByteValue {\n    return this.storage.readByte(address);\n  }\n\n  public writeByte(address: MemoryAddress, value: ByteValue): void {\n    this.storage.writeByte(address, value);\n  }\n}\n\n// In actual game boy, Working Ram and VRam are both the same component type:\n// LH5164LN-10\n\nexport const WORKING_RAM_SIZE = 0x2000;\n\nexport class WorkingRam {\n  private readonly storage: ByteRamStorage;\n\n  public constructor() {\n    this.storage = new ByteRamStorage(WORKING_RAM_SIZE);\n  }\n\n  public get values(): ReadonlyUint8Array {\n    return this.storage.values;\n  }\n\n  public readByte(address: MemoryAddress): ByteValue {\n    return this.storage.readByte(address);\n  }\n\n  public writeByte(address: MemoryAddress, value: ByteValue): void {\n    this.storage.writeByte(address, value);\n  }\n}\n\nexport const V_RAM_SIZE = 0x2000;\n\nexport type Tile = ReadonlyArray<ReadonlyArray<ColorNumber>>;\n\ntype TileTableNumber = 0 | 1;\n\ntype MemoryRange = Readonly<[MemoryAddress, MemoryAddress]>;\n\nexport type TileDataIndex = number;\n\nexport type BackgroundMap = ReadonlyArray<ReadonlyUint8Array>;\n\nexport type TileMap = ReadonlyArray<Tile>;\n\nconst TILE_DATA_TABLE_1_RANGE: MemoryRange = [0x0000, 0x1000];\nconst TILE_DATA_TABLE_2_RANGE: MemoryRange = [0x0800, 0x1800];\nconst TILE_DATA_BYTES: number = 16;\nconst TILE_DATA_DIMENSION: number = 8;\nconst TILE_DATA_INDICES: ReadonlyArray<number> =\n  range(\n    0,\n    (TILE_DATA_TABLE_1_RANGE[1] - TILE_DATA_TABLE_1_RANGE[0]) / TILE_DATA_BYTES\n  );\nconst TILE_DATA_PIXEL_INDICES: ReadonlyArray<number> =\n  range(0, TILE_DATA_DIMENSION);\nconst TILE_DATA_BIT_MASKS: ReadonlyUint8Array =\n  new Uint8Array(\n    TILE_DATA_PIXEL_INDICES\n      .map((i) => 1 << (TILE_DATA_DIMENSION - i - 1))\n  );\n\nconst BG_MAP_1_RANGE: MemoryRange = [0x1800, 0x1c00];\nconst BG_MAP_2_RANGE: MemoryRange = [0x1c00, 0x2000];\nconst BG_MAP_DIMENSION: number = 32;\nconst BG_MAP_INDICES: ReadonlyArray<number> = range(0, BG_MAP_DIMENSION);\n\nexport class VRam {\n  private readonly storage: ByteRamStorage;\n\n  public constructor() {\n    this.storage = new ByteRamStorage(V_RAM_SIZE);\n  }\n\n  public get values(): ReadonlyUint8Array {\n    return this.storage.values;\n  }\n\n  public readByte(address: MemoryAddress): ByteValue {\n    return this.storage.readByte(address);\n  }\n\n  public writeByte(address: MemoryAddress, value: ByteValue): void {\n    this.storage.writeByte(address, value);\n  }\n\n  public get bgMap1(): BackgroundMap {\n    return this.getBackgroundMap(BG_MAP_1_RANGE);\n  }\n\n  public get bgMap2(): BackgroundMap {\n    return this.getBackgroundMap(BG_MAP_2_RANGE);\n  }\n\n  private getBackgroundMap([startAddress,]: MemoryRange): BackgroundMap {\n    return BG_MAP_INDICES.map((y) =>\n      new Uint8Array(\n        BG_MAP_INDICES.map((x) => {\n          const address = startAddress + x + y * BG_MAP_DIMENSION;\n          return this.readByte(address);\n        })\n      )\n    );\n  }\n\n  public get tileMap1(): TileMap {\n    return this.getTileMap(TILE_DATA_TABLE_1_RANGE);\n  }\n\n  public get tileMap2(): TileMap {\n    return this.getTileMap(TILE_DATA_TABLE_2_RANGE);\n  }\n\n  public getTileDataFromTable1(index: TileDataIndex): Tile {\n    return this.getTileData(TILE_DATA_TABLE_1_RANGE, index);\n  }\n\n  public getTileDataFromTable2(index: TileDataIndex): Tile {\n    return this.getTileData(TILE_DATA_TABLE_2_RANGE, index);\n  }\n\n  private getTileMap(addressRange: Readonly<[MemoryAddress, MemoryAddress]>): TileMap {\n    return TILE_DATA_INDICES.map((i) => this.getTileData(addressRange, i));\n  }\n\n  private getTileData(\n    [startAddress, endAddress]: Readonly<[MemoryAddress, MemoryAddress]>,\n    index: TileDataIndex\n  ): Tile {\n    const address = startAddress + index * TILE_DATA_BYTES;\n    if (address < startAddress || address >= endAddress) {\n      throw new Error(`Tile data index ${index} is invalid`);\n    }\n    return chunk(this.storage.readBytes(address, TILE_DATA_BYTES), 2)\n      .map(([lowerBits, upperBits]) =>\n        TILE_DATA_PIXEL_INDICES.map((i) => {\n          const lower = (lowerBits & TILE_DATA_BIT_MASKS[i]) === 0 ? 0 : 1;\n          const upper = (upperBits & TILE_DATA_BIT_MASKS[i]) === 0 ? 0 : 1;\n          if (upper === 1 && lower === 1) {\n            return 3;\n          }\n          if (upper === 1 && lower === 0) {\n            return 2;\n          }\n          if (upper === 0 && lower === 1) {\n            return 1;\n          }\n          return 0;\n        })\n      );\n  }\n\n  public static initializeRandomly(): VRam {\n    const vRam = new VRam();\n    for (let i = 0; i < V_RAM_SIZE; i++) {\n      vRam.writeByte(i, Math.round(Math.random() * 0xff));\n    }\n    return vRam;\n  }\n}\n\nexport type ReadonlyVRam = Pick<\n  VRam,\n  'getTileDataFromTable1' |\n  'getTileDataFromTable2' |\n  'bgMap1' |\n  'bgMap2' |\n  'values' |\n  'tileMap1' |\n  'tileMap2' |\n  'readByte'\n>;\n\nexport class OamMemory {\n  private readonly storage: ByteRamStorage;\n\n  public constructor() {\n    this.storage = new ByteRamStorage(0xa0);\n  }\n\n  public readByte(address: MemoryAddress): ByteValue {\n    return this.storage.readByte(address);\n  }\n\n  public writeByte(address: MemoryAddress, value: ByteValue): void {\n    this.storage.writeByte(address, value);\n  }\n}\n\n// https://fms.komkon.org/GameBoy/Tech/Software.html\nexport class IOMemory {\n  private readonly storage: ByteRamStorage;\n\n  public constructor() {\n    this.storage = new ByteRamStorage(0x7f);\n  }\n\n  public readByte(address: MemoryAddress): ByteValue {\n    return this.storage.readByte(address);\n  }\n\n  public writeByte(address: MemoryAddress, value: ByteValue): void {\n    this.storage.writeByte(address, value);\n  }\n}\n"],"file":"ram.js"}