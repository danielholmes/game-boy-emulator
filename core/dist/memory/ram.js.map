{"version":3,"sources":["../../src/memory/ram.ts"],"names":["Ram","size","raw","Uint8Array","slice","value","Error","address","assertValidAddress","length","assertByte","ZeroPageRam","WorkingRam","V_RAM_SIZE","VRam","startAddress","BG_MAP_INDICES","map","y","x","BG_MAP_DIMENSION","byte","readByte","bGPNum","tileTableNumber","BG_MAP_TILE_TABLE_NUMBER_MASK","horizontalFlip","BG_MAP_HORIZONTAL_FLIP_MASK","verticalFlip","BG_MAP_VERTICAL_FLIP_MASK","useBgPriority","BG_MAP_PRIORITY_MASK","index","getTileData","TILE_DATA_TABLE_1_RANGE","TILE_DATA_TABLE_2_RANGE","endAddress","TILE_DATA_BYTES","readBytes","lowerBits","upperBits","TILE_DATA_INDICES","i","lower","TILE_DATA_BIT_MASKS","upper","getBackgroundMap","BG_MAP_1_RANGE","BG_MAP_2_RANGE","vRam","writeByte","Math","round","random","TILE_DATA_DIMENSION","OamMemory","IOMemory"],"mappings":"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","sourcesContent":["import {\n  ByteValue, ColorNumber,\n  MemoryAddress,\n  numberToHex,\n  numberToWordHex\n} from \"../types\";\nimport { range, chunk } from \"lodash\";\n\nclass Ram {\n  protected readonly raw: Uint8Array;\n  private readonly size: number;\n\n  public constructor(size: number) {\n    this.size = size;\n    this.raw = new Uint8Array(this.size);\n  }\n\n  public getValues(): Uint8Array {\n    return this.raw.slice();\n  }\n\n  private assertValidAddress(value: MemoryAddress): void {\n    if (value < 0x0000 || value >= this.size) {\n      throw new Error(\n        `Address ${numberToWordHex(value)} out of range ${numberToWordHex(\n          this.size\n        )}`\n      );\n    }\n  }\n\n  private assertByte(value: number): void {\n    if (value < 0x00 || value > 0xff) {\n      throw new Error(`Out of bounds byte ${numberToHex(value)}`);\n    }\n  }\n\n  public readByte(address: MemoryAddress): ByteValue {\n    this.assertValidAddress(address);\n    return this.raw[address];\n  }\n\n  protected readBytes(address: MemoryAddress, length: number): Uint8Array {\n    this.assertValidAddress(address);\n    this.assertValidAddress(address + length - 1);\n    return this.raw.slice(address, address + length);\n  }\n\n  public writeByte(address: MemoryAddress, value: ByteValue): void {\n    this.assertValidAddress(address);\n    this.assertByte(value);\n    this.raw[address] = value;\n  }\n}\n\nexport class ZeroPageRam extends Ram {\n  public constructor() {\n    super(0xff);\n  }\n}\n\nexport class WorkingRam extends Ram {\n  public constructor() {\n    super(0x2000);\n  }\n}\n\nexport const V_RAM_SIZE = 0x2000;\n\nexport type Tile = ReadonlyArray<ReadonlyArray<ColorNumber>>;\n\ntype TileTableNumber = 0 | 1;\ntype BackgroundMapNumber = 0 | 1;\n\ninterface BackgroundTile {\n  // Bit 0-2  Background Palette number  (BGP0-7)\n  readonly bGPNum: number;\n  // Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)\n  readonly tileTableNumber: TileTableNumber;\n  // Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)\n  readonly horizontalFlip: boolean;\n  // Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)\n  readonly verticalFlip: boolean;\n  // Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)\n  readonly useBgPriority: boolean;\n}\n\nexport type BackgroundMap = ReadonlyArray<ReadonlyArray<BackgroundTile>>;\n\ntype MemoryRange = Readonly<[MemoryAddress, MemoryAddress]>;\n\ntype TileDataIndex = number;\n\nexport class VRam extends Ram {\n  private static readonly TILE_DATA_TABLE_1_RANGE: MemoryRange = [0x0000, 0x1000];\n  private static readonly TILE_DATA_TABLE_2_RANGE: MemoryRange = [0x0800, 0x1800];\n  private static readonly TILE_DATA_BYTES: number = 16;\n  private static readonly TILE_DATA_DIMENSION: number = 8;\n  private static readonly TILE_DATA_INDICES: ReadonlyArray<number> =\n    range(0, VRam.TILE_DATA_DIMENSION);\n  private static readonly TILE_DATA_BIT_MASKS: ReadonlyArray<number> =\n    VRam.TILE_DATA_INDICES.map((i) => 1 << (VRam.TILE_DATA_DIMENSION - i - 1));\n\n  private static readonly BG_MAP_1_RANGE: MemoryRange = [0x1800, 0x1c00];\n  private static readonly BG_MAP_2_RANGE: MemoryRange = [0x1c00, 0x2000];\n  private static readonly BG_MAP_DIMENSION: number = 32;\n  private static readonly BG_MAP_TILE_TABLE_NUMBER_MASK: number = 1 << 3;\n  private static readonly BG_MAP_HORIZONTAL_FLIP_MASK: number = 1 << 5;\n  private static readonly BG_MAP_VERTICAL_FLIP_MASK: number = 1 << 6;\n  private static readonly BG_MAP_PRIORITY_MASK: number = 1 << 7;\n  private static readonly BG_MAP_INDICES: ReadonlyArray<number> =\n    range(0, VRam.BG_MAP_DIMENSION);\n\n  public constructor() {\n    super(V_RAM_SIZE);\n  }\n\n  public get bgMap1(): BackgroundMap {\n    return this.getBackgroundMap(VRam.BG_MAP_1_RANGE);\n  }\n\n  public get bgMap2(): BackgroundMap {\n    return this.getBackgroundMap(VRam.BG_MAP_2_RANGE);\n  }\n\n  private getBackgroundMap([startAddress,]: MemoryRange): BackgroundMap {\n    return VRam.BG_MAP_INDICES.map((y) =>\n      VRam.BG_MAP_INDICES.map((x) => {\n        const address = startAddress + x + y * VRam.BG_MAP_DIMENSION;\n        const byte = this.readByte(address);\n        return {\n          bGPNum: byte & 0x7,\n          tileTableNumber: (byte & VRam.BG_MAP_TILE_TABLE_NUMBER_MASK) !== 0 ? 1 as TileTableNumber : 0,\n          horizontalFlip: (byte & VRam.BG_MAP_HORIZONTAL_FLIP_MASK) !== 0,\n          verticalFlip: (byte & VRam.BG_MAP_VERTICAL_FLIP_MASK) !== 0,\n          useBgPriority: (byte & VRam.BG_MAP_PRIORITY_MASK) !== 0\n        }\n      })\n    );\n  }\n\n  public getTileDataFromTable1(index: TileDataIndex): Tile {\n    return this.getTileData(VRam.TILE_DATA_TABLE_1_RANGE, index);\n  }\n\n  public getTileDataFromTable2(index: TileDataIndex): Tile {\n    return this.getTileData(VRam.TILE_DATA_TABLE_2_RANGE, index);\n  }\n\n  private getTileData([startAddress, endAddress]: Readonly<[MemoryAddress, MemoryAddress]>, index: TileDataIndex): Tile {\n    const address = startAddress + index * VRam.TILE_DATA_BYTES;\n    if (address < startAddress || address >= endAddress) {\n      throw new Error(`Tile data index ${index} is invalid`);\n    }\n    return chunk(this.readBytes(address, VRam.TILE_DATA_BYTES), 2)\n      .map(([lowerBits, upperBits]) =>\n        VRam.TILE_DATA_INDICES.map((i) => {\n          const lower = (lowerBits & VRam.TILE_DATA_BIT_MASKS[i]) === 0 ? 0 : 1;\n          const upper = (upperBits & VRam.TILE_DATA_BIT_MASKS[i]) === 0 ? 0 : 1;\n          if (upper === 1 && lower === 1) {\n            return 3;\n          }\n          if (upper === 1 && lower === 0) {\n            return 2;\n          }\n          if (upper === 0 && lower === 1) {\n            return 1;\n          }\n          return 0;\n        })\n      );\n  }\n\n  public static initializeRandomly(): VRam {\n    const vRam = new VRam();\n    for (let i = 0; i < V_RAM_SIZE; i++) {\n      vRam.writeByte(i, Math.round(Math.random() * 0xff));\n    }\n    return vRam;\n  }\n}\n\nexport class OamMemory extends Ram {\n  public constructor() {\n    super(0xa0);\n  }\n}\n\n// https://fms.komkon.org/GameBoy/Tech/Software.html\nexport class IOMemory extends Ram {\n  public constructor() {\n    super(0x7f);\n  }\n\n  public readByte(address: MemoryAddress): ByteValue {\n    return super.readByte(address);\n  }\n\n  public writeByte(address: MemoryAddress, value: ByteValue): void {\n    // bios seems to use it\n    // if (address === 0x0044) {\n    //   throw new Error(\"Current scan line Read-only\");\n    // }\n    super.writeByte(address, value);\n  }\n}\n"],"file":"ram.js"}