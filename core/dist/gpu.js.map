{"version":3,"sources":["../src/gpu.ts"],"names":["GpuMode","Gpu","mmu","screen","modeCycles","mode","ScanlineOam","cycles","scanlineOamTick","ScanlineVRam","scanlineVRamTick","HBlank","hBlankTick","VBlank","vBlankTick"],"mappings":";;;;;;;;;;;;;;;IAIKA,O;;WAAAA,O;AAAAA,EAAAA,O,CAAAA,O;AAAAA,EAAAA,O,CAAAA,O;AAAAA,EAAAA,O,CAAAA,O;AAAAA,EAAAA,O,CAAAA,O;GAAAA,O,KAAAA,O;;IAOQC,G;;;AAMX,eAAmBC,GAAnB,EAA6BC,MAA7B,EAA6C;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAC3C,SAAKD,GAAL,GAAWA,GAAX;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKC,UAAL,GAAkB,CAAlB;AACA,SAAKC,IAAL,GAAYL,OAAO,CAACM,WAApB;AACD;;;;yBAEWC,M,EAA2B;AACrC,WAAKH,UAAL,IAAmBG,MAAnB;;AAEA,cAAQ,KAAKF,IAAb;AACE,aAAKL,OAAO,CAACM,WAAb;AACE,eAAKE,eAAL;AACA;;AACF,aAAKR,OAAO,CAACS,YAAb;AACE,eAAKC,gBAAL;AACA;;AACF,aAAKV,OAAO,CAACW,MAAb;AACE,eAAKC,UAAL;AACA;;AACF,aAAKZ,OAAO,CAACa,MAAb;AACE,eAAKC,UAAL;AACA;AAZJ,OAHqC,CAkBrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACD;;;sCAE+B;AAC9B;AACA,UAAI,KAAKV,UAAL,IAAmB,EAAvB,EAA2B;AACzB,aAAKC,IAAL,GAAYL,OAAO,CAACS,YAApB;AACA,aAAKL,UAAL,GAAkB,KAAKA,UAAL,GAAkB,EAApC;AACD;AACF;;;uCAEgC;AAC/B;AACA,UAAI,KAAKA,UAAL,IAAmB,GAAvB,EAA4B;AAC1B,aAAKC,IAAL,GAAYL,OAAO,CAACW,MAApB;AACA,aAAKP,UAAL,GAAkB,KAAKA,UAAL,GAAkB,GAApC;AACD;AACF;;;iCAE0B;AACzB;AACA,UAAI,KAAKA,UAAL,IAAmB,GAAvB,EAA4B;AAC1B,aAAKC,IAAL,GAAYL,OAAO,CAACa,MAApB;AACA,aAAKT,UAAL,GAAkB,KAAKA,UAAL,GAAkB,GAApC;AACD;AACF;;;iCAE0B;AACzB;AACA,WAAKC,IAAL,GAAYL,OAAO,CAACM,WAApB;AACD,K,CAED;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { Mmu } from \"./memory/mmu\";\nimport { Screen } from \"./screen\";\nimport { ClockCycles } from \"./cpu\";\n\nenum GpuMode {\n  HBlank = 0,\n  VBlank = 1,\n  ScanlineOam = 2,\n  ScanlineVRam = 3\n}\n\nexport class Gpu {\n  private readonly mmu: Mmu;\n  private readonly screen: Screen;\n  private modeCycles: ClockCycles;\n  private mode: GpuMode;\n\n  public constructor(mmu: Mmu, screen: Screen) {\n    this.mmu = mmu;\n    this.screen = screen;\n    this.modeCycles = 0;\n    this.mode = GpuMode.ScanlineOam;\n  }\n\n  public tick(cycles: ClockCycles): void {\n    this.modeCycles += cycles;\n\n    switch (this.mode) {\n      case GpuMode.ScanlineOam:\n        this.scanlineOamTick();\n        break;\n      case GpuMode.ScanlineVRam:\n        this.scanlineVRamTick();\n        break;\n      case GpuMode.HBlank:\n        this.hBlankTick();\n        break;\n      case GpuMode.VBlank:\n        this.vBlankTick();\n        break;\n    }\n\n    // # Mode 2\n    //   self.setSTATMode(2)\n    //   self.calculateCycles(80)\n    //\n    // # Mode 3\n    //   self.setSTATMode(3)\n    //   self.calculateCycles(170)\n    //\n    //   self.MainWindow.scanline(y, self.lcd)\n    //\n    // # Mode 0\n    //   self.setSTATMode(0)\n    //   self.calculateCycles(206)\n    //\n    //   self.cpu.setInterruptFlag(self.cpu.VBlank)\n  }\n\n  private scanlineOamTick(): void {\n    // TODO: Work\n    if (this.modeCycles >= 80) {\n      this.mode = GpuMode.ScanlineVRam;\n      this.modeCycles = this.modeCycles - 80;\n    }\n  }\n\n  private scanlineVRamTick(): void {\n    // TODO: Work\n    if (this.modeCycles >= 170) {\n      this.mode = GpuMode.HBlank;\n      this.modeCycles = this.modeCycles - 170;\n    }\n  }\n\n  private hBlankTick(): void {\n    // TODO: Work\n    if (this.modeCycles >= 206) {\n      this.mode = GpuMode.VBlank;\n      this.modeCycles = this.modeCycles - 206;\n    }\n  }\n\n  private vBlankTick(): void {\n    // throw new Error('VBlank')\n    this.mode = GpuMode.ScanlineOam;\n  }\n\n  // VRam\n  // 8000-87FF\tTile set #1: tiles 0-127\n  // 8800-8FFF\tTile set #1: tiles 128-255, Tile set #0: tiles -1 to -128\n  // 9000-97FF\tTile set #0: tiles 0-127\n  // 9800-9BFF\tTile map #0\n  // 9C00-9FFF\tTile map #1\n\n  // IO Registers\n  // FF42 - SCY - Scroll Y (R/W)\n  // FF43 - SCX - Scroll X (R/W)\n  // Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.\n  // Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.\n  //\n  // FF44 - LY - LCDC Y-Coordinate (R)\n  // The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.\n  //\n  // FF45 - LYC - LY Compare (R/W)\n  // The gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.\n  //\n  // FF4A - WY - Window Y Position (R/W)\n  // FF4B - WX - Window X Position minus 7 (R/W)\n  // Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behinf the window, just as for normal BG.)\n  // The window becomes visible (if enabled) when\n}\n"],"file":"gpu.js"}