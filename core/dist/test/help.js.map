{"version":3,"sources":["../../src/test/help.ts"],"names":["createMmu","Mmu","bios","WorkingRam","VRam","IOMemory","OamMemory","ZeroPageRam","EMPTY_MEMORY","isRegister","name","createCpuWithRegisters","withRegisters","cpu","Cpu","forEach","register","value","registers","createCpuRegistersWithRegisters","createMmuWithValues","values","mmu","address","writeByte","parseInt","createMmuWithCartridgeAndValues","cartridge","loadCartridge","createMemorySnapshot","createCpuSnapshot"],"mappings":";;;;;;;AACA;;AAEA;;AACA;;AACA;;AAOA;;;;;;;;;;;;;;AAGO,IAAMA,SAAS,GAAG,SAAZA,SAAY;AAAA,SACvB,IAAIC,QAAJ,CACEC,aADF,EAEE,IAAIC,eAAJ,EAFF,EAGE,IAAIC,SAAJ,EAHF,EAIE,IAAIC,aAAJ,EAJF,EAKE,IAAIC,cAAJ,EALF,EAME,IAAIC,gBAAJ,EANF,CADuB;AAAA,CAAlB;;;AAUA,IAAMC,YAAY,GAAGR,SAAS,EAA9B,C,CAEP;;;;AACA,IAAMS,UAAU,GAAG,SAAbA,UAAa,CAACC,IAAD;AAAA,SAAoC,CAAC,CAACA,IAAtC;AAAA,CAAnB;;AAEO,IAAMC,sBAAsB,GAAG,SAAzBA,sBAAyB,CACpCC,aADoC,EAE5B;AACR,MAAMC,GAAG,GAAG,IAAIC,QAAJ,EAAZ;AACA,uBAAQF,aAAR,EAAuBG,OAAvB,CAA+B,gBAAuB;AAAA;AAAA,QAArBC,QAAqB;AAAA,QAAXC,KAAW;;AACpD,QAAIR,UAAU,CAACO,QAAD,CAAV,IAAwB,OAAOC,KAAP,KAAiB,WAA7C,EAA0D;AACxDJ,MAAAA,GAAG,CAACK,SAAJ,CAAcF,QAAd,IAA0BC,KAA1B;AACD;AACF,GAJD;AAKA,SAAOJ,GAAP;AACD,CAVM;;;;AAYA,IAAMM,+BAA+B,GAAG,SAAlCA,+BAAkC,CAC7CP,aAD6C,EAE5B;AACjB,SAAOD,sBAAsB,CAACC,aAAD,CAAtB,CAAsCM,SAA7C;AACD,CAJM;;;;AAMA,IAAME,mBAAmB,GAAG,SAAtBA,mBAAsB,CAACC,MAAD,EAExB;AACT,MAAMC,GAAG,GAAGtB,SAAS,EAArB;AACA,uBAAQqB,MAAR,EAAgBN,OAAhB,CAAwB;AAAA;AAAA,QAAEQ,OAAF;AAAA,QAAWN,KAAX;;AAAA,WACtBK,GAAG,CAACE,SAAJ,CAAcC,QAAQ,CAACF,OAAD,CAAtB,EAAiCN,KAAjC,CADsB;AAAA,GAAxB;AAGA,SAAOK,GAAP;AACD,CARM;;;;AAUA,IAAMI,+BAA+B,GAAG,SAAlCA,+BAAkC,CAC7CC,SAD6C,EAE7CN,MAF6C,EAGrC;AACR,MAAMC,GAAG,GAAGF,mBAAmB,CAACC,MAAM,IAAI,EAAX,CAA/B;AACAC,EAAAA,GAAG,CAACM,aAAJ,CAAkBD,SAAlB;AACA,SAAOL,GAAP;AACD,CAPM,C,CASP;;;;;AACO,IAAMO,oBAAoB,GAAG,SAAvBA,oBAAuB,CAACP,GAAD,EAAsB;AACxD,iBAAcA,GAAd;AACD,CAFM,C,CAIP;;;;;AACO,IAAMQ,iBAAiB,GAAG,SAApBA,iBAAoB,CAACjB,GAAD,EAAsB;AACrD,iBAAcA,GAAd;AACD,CAFM","sourcesContent":["import { CpuRegisters, Register } from \"../cpu/registers\";\nimport { toPairs } from \"lodash\";\nimport { ByteValue } from \"../types\";\nimport { Mmu } from \"../memory/mmu\";\nimport bios from \"../bios\";\nimport {\n  IOMemory,\n  OamMemory,\n  VRam,\n  WorkingRam,\n  ZeroPageRam\n} from \"../memory/ram\";\nimport { Cpu } from \"../cpu\";\nimport { Cartridge } from \"../cartridge\";\n\nexport const createMmu = (): Mmu =>\n  new Mmu(\n    bios,\n    new WorkingRam(),\n    new VRam(),\n    new IOMemory(),\n    new OamMemory(),\n    new ZeroPageRam()\n  );\n\nexport const EMPTY_MEMORY = createMmu();\n\n// Dummy to get around typing\nconst isRegister = (name: string): name is Register => !!name;\n\nexport const createCpuWithRegisters = (\n  withRegisters: Partial<CpuRegisters>\n): Cpu => {\n  const cpu = new Cpu();\n  toPairs(withRegisters).forEach(([register, value]) => {\n    if (isRegister(register) && typeof value !== \"undefined\") {\n      cpu.registers[register] = value;\n    }\n  });\n  return cpu;\n};\n\nexport const createCpuRegistersWithRegisters = (\n  withRegisters: Partial<CpuRegisters>\n): CpuRegisters => {\n  return createCpuWithRegisters(withRegisters).registers;\n};\n\nexport const createMmuWithValues = (values: {\n  [address: number]: ByteValue;\n}): Mmu => {\n  const mmu = createMmu();\n  toPairs(values).forEach(([address, value]) =>\n    mmu.writeByte(parseInt(address), value)\n  );\n  return mmu;\n};\n\nexport const createMmuWithCartridgeAndValues = (\n  cartridge: Cartridge,\n  values?: { [address: number]: ByteValue }\n): Mmu => {\n  const mmu = createMmuWithValues(values || {});\n  mmu.loadCartridge(cartridge);\n  return mmu;\n};\n\n// TODO:\nexport const createMemorySnapshot = (mmu: Mmu): string => {\n  return typeof mmu;\n};\n\n// TODO:\nexport const createCpuSnapshot = (cpu: Cpu): string => {\n  return typeof cpu;\n};\n"],"file":"help.js"}