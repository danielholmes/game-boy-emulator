{"version":3,"sources":["../../src/cpu/lowLevel.ts"],"names":["LoadRegister","register","cpu","registers","ReadMemory","mmu","value","undefined","Error","readByte","LoadGroupedRegister","WriteWordFromGroupedRegisterAddress","address","writeByte","BitFlags","t","FLAG_Z_MASK","flag","FLAG_Z","f","JrCheck","fNz","pc","WordValueToSignedByte","WriteByteFromOperandAddress","readBigEndianWord","WriteWordFromOperandAddress","writeWordBigEndian","StoreInRegister","StoreInGroupedRegister","DecrementStackPointer","amount","sp","LoadProgramCounter","WriteMemoryFromOperandAddress","operand","WriteMemoryFromRegisterAddress","WriteMemoryFromStackPointer","StoreInStackPointer","SetProgramCounter","LoadOperand","byte","LoadWordOperand","IncrementRegister","IncrementGroupedRegister","XOrRegister","a","Nop","IncrementStackPointer","LoadStackPointer","DecrementRegister","DecrementGroupedRegister"],"mappings":"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","sourcesContent":["import { Mmu } from \"../memory/mmu\";\nimport {\n  ByteRegister,\n  FLAG_Z,\n  FLAG_Z_MASK,\n  GroupedWordRegister,\n  Register\n} from \"./registers\";\nimport { ByteValue, WordValue, byteValueToSignedByte } from \"../types\";\nimport { Cpu, ClockCycles } from \".\";\n\nexport type LowLevelState = ByteValue | WordValue | undefined;\nexport type LowLevelStateReturn = ByteValue | WordValue | void;\n\n// Read16BitOperand // loads two bytes -> takes 8 cycles\n// LoadByteFromMemory // loads one byte -> takes 4 cycles\n// StoreToRegister(\"A\") // takes no extra cycles\n\nexport interface LowLevelOperation {\n  readonly cycles: ClockCycles;\n  execute(cpu: Cpu, mmu: Mmu, value: LowLevelState): LowLevelStateReturn;\n}\n\nexport class LoadRegister implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 0;\n  private readonly register: ByteRegister;\n\n  public constructor(register: ByteRegister) {\n    this.register = register;\n  }\n\n  public execute(cpu: Cpu): LowLevelStateReturn {\n    return cpu.registers[this.register];\n  }\n}\n\nexport class ReadMemory implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 4;\n\n  public execute(\n    cpu: Cpu,\n    mmu: Mmu,\n    value: LowLevelState\n  ): LowLevelStateReturn {\n    if (value === undefined) {\n      throw new Error(\"value undefined\");\n    }\n    return mmu.readByte(value);\n  }\n}\n\nexport class LoadGroupedRegister implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 0;\n  private readonly register: GroupedWordRegister;\n\n  public constructor(register: GroupedWordRegister) {\n    this.register = register;\n  }\n\n  public execute(cpu: Cpu): LowLevelStateReturn {\n    return cpu.registers[this.register];\n  }\n}\n\nexport class WriteWordFromGroupedRegisterAddress implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 4;\n  private readonly register: GroupedWordRegister;\n\n  public constructor(register: GroupedWordRegister) {\n    this.register = register;\n  }\n\n  public execute(\n    cpu: Cpu,\n    mmu: Mmu,\n    value: LowLevelState\n  ): LowLevelStateReturn {\n    if (value === undefined) {\n      throw new Error(\"value undefined\");\n    }\n    const address = cpu.registers[this.register];\n    mmu.writeByte(address, value);\n  }\n}\n\nexport class BitFlags implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 0;\n  private readonly register: ByteRegister;\n\n  public constructor(register: ByteRegister) {\n    this.register = register;\n  }\n\n  public execute(cpu: Cpu): LowLevelStateReturn {\n    const t = cpu.registers[this.register] & FLAG_Z_MASK;\n    const flag = 0x20 + (((t & 0xff) === 0 ? 1 : 0) << FLAG_Z);\n    cpu.registers.f &= 0x10;\n    cpu.registers.f |= flag;\n  }\n}\n\nexport class JrCheck implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 0;\n\n  public execute(\n    cpu: Cpu,\n    mmu: Mmu,\n    value: LowLevelState\n  ): LowLevelStateReturn {\n    if (value === undefined) {\n      throw new Error(\"value undefined\");\n    }\n\n    if (cpu.registers.fNz) {\n      // TODO: Becomes a longer cycle operation\n      cpu.registers.pc += value;\n    }\n  }\n}\n\nexport class WordValueToSignedByte implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 0;\n\n  public execute(\n    cpu: Cpu,\n    mmu: Mmu,\n    value: LowLevelState\n  ): LowLevelStateReturn {\n    if (value === undefined) {\n      throw new Error(\"value undefined\");\n    }\n\n    return byteValueToSignedByte(value);\n  }\n}\n\nexport class WriteByteFromOperandAddress implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 12;\n\n  public execute(\n    cpu: Cpu,\n    mmu: Mmu,\n    value: LowLevelState\n  ): LowLevelStateReturn {\n    if (value === undefined) {\n      throw new Error(\"value undefined\");\n    }\n    const address = mmu.readBigEndianWord(cpu.registers.pc);\n    mmu.writeByte(address, value);\n    cpu.registers.pc += 2;\n  }\n}\n\nexport class WriteWordFromOperandAddress implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 12;\n\n  public execute(\n    cpu: Cpu,\n    mmu: Mmu,\n    value: LowLevelState\n  ): LowLevelStateReturn {\n    if (value === undefined) {\n      throw new Error(\"value undefined\");\n    }\n    const address = mmu.readBigEndianWord(cpu.registers.pc);\n    mmu.writeWordBigEndian(address, value);\n    cpu.registers.pc += 2;\n  }\n}\n\nexport class StoreInRegister implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 0;\n  private readonly register: ByteRegister;\n\n  public constructor(register: ByteRegister) {\n    this.register = register;\n  }\n\n  public execute(\n    cpu: Cpu,\n    mmu: Mmu,\n    value: LowLevelState\n  ): LowLevelStateReturn {\n    if (value === undefined) {\n      throw new Error(\"value not defined\");\n    }\n    cpu.registers[this.register] = value & 255;\n  }\n}\n\nexport class StoreInGroupedRegister implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 0;\n  private readonly register: GroupedWordRegister;\n\n  public constructor(register: GroupedWordRegister) {\n    this.register = register;\n  }\n\n  public execute(\n    cpu: Cpu,\n    mmu: Mmu,\n    value: LowLevelState\n  ): LowLevelStateReturn {\n    if (value === undefined) {\n      throw new Error(\"value not defined\");\n    }\n    cpu.registers[this.register] = value;\n  }\n}\n\nexport class DecrementStackPointer implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 4;\n  private readonly amount: WordValue;\n\n  public constructor(amount: WordValue) {\n    this.amount = amount;\n  }\n\n  public execute(cpu: Cpu): LowLevelStateReturn {\n    cpu.registers.sp -= this.amount;\n  }\n}\n\nexport class LoadProgramCounter implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 4;\n\n  public execute(cpu: Cpu): LowLevelStateReturn {\n    return cpu.registers.pc;\n  }\n}\n\nexport class WriteMemoryFromOperandAddress implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 8;\n\n  public execute(\n    cpu: Cpu,\n    mmu: Mmu,\n    value: LowLevelState\n  ): LowLevelStateReturn {\n    if (value === undefined) {\n      throw new Error(\"value undefined\");\n    }\n    const operand = mmu.readByte(cpu.registers.pc);\n    mmu.writeWordBigEndian(0xff00 + operand, value);\n    cpu.registers.pc++;\n  }\n}\n\nexport class WriteMemoryFromRegisterAddress implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 4;\n  private readonly register: Register;\n\n  public constructor(register: Register) {\n    this.register = register;\n  }\n\n  public execute(\n    cpu: Cpu,\n    mmu: Mmu,\n    value: LowLevelState\n  ): LowLevelStateReturn {\n    if (value === undefined) {\n      throw new Error(\"value undefined\");\n    }\n    mmu.writeWordBigEndian(0xff00 + cpu.registers[this.register], value);\n  }\n}\n\nexport class WriteMemoryFromStackPointer implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 16;\n\n  public execute(\n    cpu: Cpu,\n    mmu: Mmu,\n    value: LowLevelState\n  ): LowLevelStateReturn {\n    if (value === undefined) {\n      throw new Error(\"value undefined\");\n    }\n    mmu.writeWordBigEndian(cpu.registers.sp, value);\n  }\n}\n\nexport class StoreInStackPointer implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 0;\n\n  public execute(\n    cpu: Cpu,\n    mmu: Mmu,\n    value: LowLevelState\n  ): LowLevelStateReturn {\n    if (value === undefined) {\n      throw new Error(\"value not defined\");\n    }\n    cpu.registers.sp = value;\n  }\n}\n\nexport class SetProgramCounter implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 4;\n  private readonly value: WordValue;\n\n  public constructor(value: WordValue) {\n    this.value = value;\n  }\n\n  public execute(cpu: Cpu): LowLevelStateReturn {\n    cpu.registers.pc = this.value;\n  }\n}\n\n// TODO: Can be done in terms of lower level ops\nexport class LoadOperand implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 4;\n\n  public execute(cpu: Cpu, mmu: Mmu): LowLevelStateReturn {\n    const byte = mmu.readByte(cpu.registers.pc);\n    cpu.registers.pc++;\n    return byte;\n  }\n}\n\nexport class LoadWordOperand implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 8;\n\n  public execute(cpu: Cpu, mmu: Mmu): LowLevelStateReturn {\n    const byte = mmu.readBigEndianWord(cpu.registers.pc);\n    cpu.registers.pc += 2;\n    return byte;\n  }\n}\n\nexport class IncrementRegister implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 0;\n  private readonly register: Register;\n\n  public constructor(register: Register) {\n    this.register = register;\n  }\n\n  public execute(cpu: Cpu): LowLevelStateReturn {\n    cpu.registers[this.register]++;\n  }\n}\n\nexport class IncrementGroupedRegister implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 0;\n  private readonly register: GroupedWordRegister;\n\n  public constructor(register: GroupedWordRegister) {\n    this.register = register;\n  }\n\n  public execute(cpu: Cpu): LowLevelStateReturn {\n    cpu.registers[this.register]++;\n  }\n}\n\nexport class XOrRegister implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 0;\n  private readonly register: ByteRegister;\n\n  public constructor(register: ByteRegister) {\n    this.register = register;\n  }\n\n  public execute(cpu: Cpu): LowLevelStateReturn {\n    cpu.registers.a = cpu.registers[this.register] & 0xff;\n    cpu.registers.f = cpu.registers.a ? 0x00 : 0x80;\n  }\n}\n\nexport class Nop implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 0;\n\n  public execute(): LowLevelStateReturn {}\n}\n\nexport class IncrementStackPointer implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 4;\n\n  public execute(cpu: Cpu): LowLevelStateReturn {\n    cpu.registers.sp++;\n  }\n}\n\nexport class LoadStackPointer implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 4;\n\n  public execute(cpu: Cpu): LowLevelStateReturn {\n    return cpu.registers.sp;\n  }\n}\n\nexport class DecrementRegister implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 0;\n  private readonly register: ByteRegister;\n\n  public constructor(register: ByteRegister) {\n    this.register = register;\n  }\n\n  public execute(cpu: Cpu): LowLevelStateReturn {\n    cpu.registers[this.register]--;\n  }\n}\n\n// TODO: Depending on cycles, make this WordRegister\nexport class DecrementGroupedRegister implements LowLevelOperation {\n  public readonly cycles: ClockCycles = 0;\n  private readonly register: GroupedWordRegister;\n\n  public constructor(register: GroupedWordRegister) {\n    this.register = register;\n  }\n\n  public execute(cpu: Cpu): LowLevelStateReturn {\n    cpu.registers[this.register]--;\n  }\n}\n"],"file":"lowLevel.js"}