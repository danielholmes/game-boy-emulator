{"version":3,"sources":["../../src/cpu/call.ts"],"names":["createCallNn","opCode","InstructionDefinition","loadProgramCounter","pushWordToStack","internalDelay","loadWordOperand","storeInRegister","createCallFNn","flag","setToPcIfFlag"],"mappings":";;;;;;;AAAA;;AAGO,IAAMA,YAAY,GAAG,SAAfA,YAAe,CAACC,MAAD;AAAA,SAC1B,IAAIC,mCAAJ,CAA0BD,MAA1B,EAAkC,SAAlC,EACGE,kBADH,GAEGC,eAFH,GAGGC,aAHH,GAIGC,eAJH,GAKGC,eALH,CAKmB,IALnB,CAD0B;AAAA,CAArB;;;;AAQA,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAACP,MAAD,EAAiBQ,IAAjB;AAAA,SAC3B,IAAIP,mCAAJ,CAA0BD,MAA1B,iBAA0CQ,IAA1C,UACGH,eADH,GAEGI,aAFH,CAEiBD,IAFjB,CAD2B;AAAA,CAAtB,C,CAKP;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { Instruction, InstructionDefinition, OpCode } from \"./instructions\";\nimport { CheckFlag } from \"./lowLevel\";\n\nexport const createCallNn = (opCode: OpCode): Instruction =>\n  new InstructionDefinition(opCode, \"CALL nn\")\n    .loadProgramCounter()\n    .pushWordToStack()\n    .internalDelay()\n    .loadWordOperand()\n    .storeInRegister(\"pc\");\n\nexport const createCallFNn = (opCode: OpCode, flag: CheckFlag): Instruction =>\n  new InstructionDefinition(opCode, `CALL ${flag},nn`)\n    .loadWordOperand()\n    .setToPcIfFlag(flag);\n\n// TODO: Only load word IF needed, thus changes cycles depending on call\n\n// TODO: See tests mentioned here: https://github.com/Gekkio/mooneye-gb/blob/master/docs/accuracy.markdown#what-is-the-exact-timing-of-calljpjr-not-jp-hl\n// TODO: Ordering is wrong\n// M = 0: instruction decoding\n// M = 1: nn read: memory access for low byte\n// M = 2: nn read: memory access for high byte\n// ; cc matches or unconditional\n// M = 3: internal delay\n// M = 4: PC push: memory access for high byte\n// M = 5: PC push: memory access for low byte\n"],"file":"call.js"}