{"version":3,"sources":["../../src/cpu/instructions.ts"],"names":["InstructionDefinition","opCode","label","operations","cpu","mmu","reduce","value","op","newResult","execute","undefined","map","cycles","register","withOperation","RotateLeftThroughCarry","InternalDelay","XOrRegister","flag","JrCheck","position","BitFlags","CompareToRegister","LoadRegister","loadRegister","WriteMemoryHighByteFromOperandAddress","WriteMemoryLowByteFromOperandAddress","incrementRegister","WriteMemoryFromRegisterAddress","LoadOperand","loadByteOperand","ByteValueToSignedByte","LoadWordOperandHighByte","DecrementByteRegisterWithFlags","DecrementRegister","IncrementWordRegisterWithFlags","IncrementByteRegisterWithFlags","IncrementRegister","StoreInRegister","ReadMemory","ReadMemoryWord","WriteByteFromOperandAddress","WriteWordFromOperandAddress","address","SetRegister","decrementRegister","writeMemoryWordFromStackPointer","WriteMemoryWordHighByteFromStackPointer","WriteMemoryWordLowByteFromStackPointer","operation"],"mappings":"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","sourcesContent":["import { Mmu } from \"../memory/mmu\";\nimport {\n  BitFlags,\n  DecrementRegister,\n  DecrementByteRegisterWithFlags,\n  IncrementRegister,\n  JrCheck,\n  LoadOperand,\n  LoadWordOperandHighByte,\n  LoadRegister,\n  LowLevelOperation,\n  LowLevelState,\n  ReadMemory,\n  SetRegister,\n  StoreInRegister,\n  WriteByteFromOperandAddress,\n  XOrRegister,\n  ByteValueToSignedByte,\n  WriteWordFromOperandAddress,\n  WriteMemoryFromRegisterAddress,\n  WriteMemoryLowByteFromOperandAddress,\n  WriteMemoryHighByteFromOperandAddress,\n  InternalDelay,\n  WriteMemoryWordHighByteFromStackPointer,\n  WriteMemoryWordLowByteFromStackPointer,\n  RotateLeftThroughCarry,\n  ReadMemoryWord,\n  CompareToRegister,\n  JrFlag,\n  IncrementByteRegisterWithFlags,\n  IncrementWordRegisterWithFlags\n} from \"./lowLevel\";\nimport {\n  ByteRegister,\n  Register,\n  WordRegister\n} from \"./registers\";\nimport { sum } from \"lodash\";\nimport { ByteBitPosition, MemoryAddress } from \"../types\";\nimport { Cpu, ClockCycles } from \"./index\";\n\nexport type OpCode = number;\n\nexport interface Instruction {\n  readonly opCode: OpCode;\n  readonly label: string;\n  execute(cpu: Cpu, mmu: Mmu): ClockCycles;\n}\n\n// TODO: Definition to generate label?\n\n// TODO: A chained instruction definition that only allows valid\n// e.g. not allow loadFromRegister.loadFromRegister\n// if even relevant, see how other instructions pan out\nexport class InstructionDefinition implements Instruction {\n  public readonly opCode: OpCode;\n  public readonly label: string;\n  private readonly operations: ReadonlyArray<LowLevelOperation>;\n\n  public constructor(\n    opCode: OpCode,\n    label: string,\n    operations: ReadonlyArray<LowLevelOperation> = []\n  ) {\n    this.opCode = opCode;\n    this.label = label;\n    this.operations = operations;\n  }\n\n  public execute(cpu: Cpu, mmu: Mmu): ClockCycles {\n    this.operations.reduce(\n      (value: LowLevelState, op: LowLevelOperation): LowLevelState => {\n        const newResult = op.execute(cpu, mmu, value);\n        return typeof newResult === \"undefined\" ? undefined : newResult;\n      },\n      undefined\n    );\n    return sum(this.operations.map(op => op.cycles));\n  }\n\n  public rotateLeftThroughCarry(register: ByteRegister): InstructionDefinition {\n    return this.withOperation(new RotateLeftThroughCarry(register));\n  }\n\n  public internalDelay(): InstructionDefinition {\n    return this.withOperation(new InternalDelay());\n  }\n\n  public xOr(register: ByteRegister): InstructionDefinition {\n    return this.withOperation(new XOrRegister(register));\n  }\n\n  public jrCheck(flag: JrFlag): InstructionDefinition {\n    return this.withOperation(new JrCheck(flag));\n  }\n\n  public bitFlags(position: ByteBitPosition): InstructionDefinition {\n    return this.withOperation(new BitFlags(position));\n  }\n\n  public compareToRegister(register: Register): InstructionDefinition {\n    return this.withOperation(new CompareToRegister(register));\n  }\n\n  public loadRegister(register: Register): InstructionDefinition {\n    return this.withOperation(new LoadRegister(register));\n  }\n\n  public loadProgramCounter(): InstructionDefinition {\n    return this.loadRegister(\"pc\");\n  }\n\n  public writeMemoryFromOperandAddress(): InstructionDefinition {\n    return this.withOperation(new WriteMemoryHighByteFromOperandAddress())\n      .withOperation(new WriteMemoryLowByteFromOperandAddress())\n      .incrementRegister(\"pc\");\n  }\n\n  public writeMemoryFromFf00PlusRegisterAddress(\n    register: ByteRegister\n  ): InstructionDefinition {\n    return this.withOperation(new WriteMemoryFromRegisterAddress(register, 0xff00));\n  }\n\n  public writeMemoryFromWordRegisterAddress(register: WordRegister): InstructionDefinition {\n    return this.withOperation(\n      new WriteMemoryFromRegisterAddress(register)\n    );\n  }\n\n  public loadByteOperand(): InstructionDefinition {\n    return this.withOperation(new LoadOperand());\n  }\n\n  public loadSignedByteOperand(): InstructionDefinition {\n    return this.loadByteOperand().withOperation(new ByteValueToSignedByte());\n  }\n\n  public loadWordOperand(): InstructionDefinition {\n    return this.loadByteOperand().withOperation(new LoadWordOperandHighByte());\n  }\n\n  public decrementByteRegisterWithFlags(register: ByteRegister): InstructionDefinition {\n    return this.withOperation(new DecrementByteRegisterWithFlags(register));\n  }\n\n  public decrementRegister(register: Register): InstructionDefinition {\n    return this.withOperation(new DecrementRegister(register));\n  }\n\n  public incrementWordRegisterWithFlags(\n    register: WordRegister\n  ): InstructionDefinition {\n    return this.withOperation(new IncrementWordRegisterWithFlags(register));\n  }\n\n  public incrementByteRegisterWithFlags(\n    register: ByteRegister\n  ): InstructionDefinition {\n    return this.withOperation(new IncrementByteRegisterWithFlags(register));\n  }\n\n  public incrementRegister(register: Register): InstructionDefinition {\n    return this.withOperation(new IncrementRegister(register));\n  }\n\n  public storeInRegister(register: Register): InstructionDefinition {\n    return this.withOperation(new StoreInRegister(register));\n  }\n\n  public readMemory(): InstructionDefinition {\n    return this.withOperation(new ReadMemory());\n  }\n\n  public readMemoryWord(): InstructionDefinition {\n    return this.withOperation(new ReadMemoryWord());\n  }\n\n  public writeByteFromWordOperandAddress(): InstructionDefinition {\n    return this.withOperation(new WriteByteFromOperandAddress());\n  }\n\n  public writeWordFromProgramWord(): InstructionDefinition {\n    return this.withOperation(new WriteWordFromOperandAddress());\n  }\n\n  public setRegister(\n    register: Register,\n    address: MemoryAddress\n  ): InstructionDefinition {\n    return this.withOperation(new SetRegister(register, address));\n  }\n\n  public pushWordToStack(): InstructionDefinition {\n    return this.decrementRegister(\"sp\")\n      .decrementRegister(\"sp\")\n      .writeMemoryWordFromStackPointer();\n  }\n\n  public writeMemoryWordFromStackPointer(): InstructionDefinition {\n    return this.withOperation(\n      new WriteMemoryWordHighByteFromStackPointer()\n    ).withOperation(new WriteMemoryWordLowByteFromStackPointer());\n  }\n\n  private withOperation(operation: LowLevelOperation): InstructionDefinition {\n    return new InstructionDefinition(this.opCode, this.label, [\n      ...this.operations,\n      operation\n    ]);\n  }\n}\n"],"file":"instructions.js"}