{"version":3,"sources":["../../src/cpu/instructions.ts"],"names":["InstructionDefinition","opCode","label","operations","cpu","mmu","reduce","value","op","newResult","execute","undefined","map","cycles","register","withOperation","RotateLeftThroughCarry","InternalDelay","XOrRegister","JrCheck","BitFlags","CompareToRegister","LoadRegister","loadRegister","WriteMemoryHighByteFromOperandAddress","WriteMemoryLowByteFromOperandAddress","incrementRegister","WriteMemoryFromRegisterAddress","WriteWordFromGroupedRegisterAddress","LoadOperand","loadByteOperand","WordValueToSignedByte","LoadWordOperand","DecrementRegister","IncrementRegister","StoreInRegister","ReadMemory","ReadMemoryWord","WriteByteFromOperandAddress","WriteWordFromOperandAddress","address","SetRegister","decrementRegister","writeMemoryWordFromStackPointer","WriteMemoryWordHighByteFromStackPointer","WriteMemoryWordLowByteFromStackPointer","operation"],"mappings":"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","sourcesContent":["import { Mmu } from \"../memory/mmu\";\nimport {\n  BitFlags,\n  DecrementRegister,\n  IncrementRegister,\n  JrCheck,\n  LoadOperand,\n  LoadWordOperand,\n  LoadRegister,\n  LowLevelOperation,\n  LowLevelState,\n  ReadMemory,\n  SetRegister,\n  StoreInRegister,\n  WriteWordFromGroupedRegisterAddress,\n  WriteByteFromOperandAddress,\n  XOrRegister,\n  WordValueToSignedByte,\n  WriteWordFromOperandAddress,\n  WriteMemoryFromRegisterAddress,\n  WriteMemoryLowByteFromOperandAddress,\n  WriteMemoryHighByteFromOperandAddress,\n  InternalDelay,\n  WriteMemoryWordHighByteFromStackPointer,\n  WriteMemoryWordLowByteFromStackPointer,\n  RotateLeftThroughCarry,\n  ReadMemoryWord, CompareToRegister\n} from \"./lowLevel\";\nimport { ByteRegister, NonAfGroupedWordRegister, Register } from \"./registers\";\nimport { sum } from \"lodash\";\nimport { MemoryAddress } from \"../types\";\nimport { Cpu, ClockCycles } from \"./index\";\n\nexport type OpCode = number;\n\nexport interface Instruction {\n  readonly opCode: OpCode;\n  readonly label: string;\n  execute(cpu: Cpu, mmu: Mmu): ClockCycles;\n}\n\n// TODO: Definition to generate label?\n\n// TODO: A chained instruction definition that only allows valid\n// e.g. not allow loadFromRegister.loadFromRegister\n// if even relevant, see how other instructions pan out\nexport class InstructionDefinition implements Instruction {\n  public readonly opCode: OpCode;\n  public readonly label: string;\n  private readonly operations: ReadonlyArray<LowLevelOperation>;\n\n  public constructor(\n    opCode: OpCode,\n    label: string,\n    operations: ReadonlyArray<LowLevelOperation> = []\n  ) {\n    this.opCode = opCode;\n    this.label = label;\n    this.operations = operations;\n  }\n\n  public execute(cpu: Cpu, mmu: Mmu): ClockCycles {\n    this.operations.reduce(\n      (value: LowLevelState, op: LowLevelOperation): LowLevelState => {\n        const newResult = op.execute(cpu, mmu, value);\n        return typeof newResult === \"undefined\" ? undefined : newResult;\n      },\n      undefined\n    );\n    return sum(this.operations.map(op => op.cycles));\n  }\n\n  public rotateLeftThroughCarry(register: ByteRegister): InstructionDefinition {\n    return this.withOperation(new RotateLeftThroughCarry(register));\n  }\n\n  public internalDelay(): InstructionDefinition {\n    return this.withOperation(new InternalDelay());\n  }\n\n  public xOr(register: ByteRegister): InstructionDefinition {\n    return this.withOperation(new XOrRegister(register));\n  }\n\n  public jrCheck(): InstructionDefinition {\n    return this.withOperation(new JrCheck());\n  }\n\n  public bitFlags(register: ByteRegister): InstructionDefinition {\n    return this.withOperation(new BitFlags(register));\n  }\n\n  public compareToRegister(register: Register): InstructionDefinition {\n    return this.withOperation(new CompareToRegister(register));\n  }\n\n  public loadRegister(register: Register): InstructionDefinition {\n    return this.withOperation(new LoadRegister(register));\n  }\n\n  public loadProgramCounter(): InstructionDefinition {\n    return this.loadRegister(\"pc\");\n  }\n\n  public writeMemoryFromOperandAddress(): InstructionDefinition {\n    return this.withOperation(new WriteMemoryHighByteFromOperandAddress())\n      .withOperation(new WriteMemoryLowByteFromOperandAddress())\n      .incrementRegister(\"pc\");\n  }\n\n  public writeMemoryFromRegisterAddress(\n    register: Register\n  ): InstructionDefinition {\n    return this.withOperation(new WriteMemoryFromRegisterAddress(register));\n  }\n\n  public writeMemoryFromGroupedRegisterAddress(\n    register: NonAfGroupedWordRegister\n  ): InstructionDefinition {\n    return this.withOperation(\n      new WriteWordFromGroupedRegisterAddress(register)\n    );\n  }\n\n  public loadByteOperand(): InstructionDefinition {\n    return this.withOperation(new LoadOperand());\n  }\n\n  public loadSignedByteOperand(): InstructionDefinition {\n    return this.loadByteOperand().withOperation(new WordValueToSignedByte());\n  }\n\n  public loadWordOperand(): InstructionDefinition {\n    return this.withOperation(new LoadWordOperand());\n  }\n\n  public decrementRegister(register: Register): InstructionDefinition {\n    return this.withOperation(new DecrementRegister(register));\n  }\n\n  public incrementRegister(register: Register): InstructionDefinition {\n    return this.withOperation(new IncrementRegister(register));\n  }\n\n  public storeInRegister(register: Register): InstructionDefinition {\n    return this.withOperation(new StoreInRegister(register));\n  }\n\n  public readMemory(): InstructionDefinition {\n    return this.withOperation(new ReadMemory());\n  }\n\n  public readMemoryWord(): InstructionDefinition {\n    return this.withOperation(new ReadMemoryWord());\n  }\n\n  public writeByteFromWordOperandAddress(): InstructionDefinition {\n    return this.withOperation(new WriteByteFromOperandAddress());\n  }\n\n  public writeWordFromProgramWord(): InstructionDefinition {\n    return this.withOperation(new WriteWordFromOperandAddress());\n  }\n\n  public setRegister(\n    register: Register,\n    address: MemoryAddress\n  ): InstructionDefinition {\n    return this.withOperation(new SetRegister(register, address));\n  }\n\n  public pushWordToStack(): InstructionDefinition {\n    return this.decrementRegister(\"sp\")\n      .decrementRegister(\"sp\")\n      .writeMemoryWordFromStackPointer();\n  }\n\n  public writeMemoryWordFromStackPointer(): InstructionDefinition {\n    return this.withOperation(\n      new WriteMemoryWordHighByteFromStackPointer()\n    ).withOperation(new WriteMemoryWordLowByteFromStackPointer());\n  }\n\n  private withOperation(operation: LowLevelOperation): InstructionDefinition {\n    return new InstructionDefinition(this.opCode, this.label, [\n      ...this.operations,\n      operation\n    ]);\n  }\n}\n"],"file":"instructions.js"}