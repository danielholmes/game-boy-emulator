{"version":3,"sources":["../../src/cpu/cb.ts"],"names":["CbInstruction","opCode","cpu","mmu","operand","readByte","registers","pc","subInstruction","CB_INSTRUCTIONS","Error","execute","createCb","createCbBit","register","InstructionDefinition","bitFlags","map","i"],"mappings":";;;;;;;AAAA;;AAEA;;AACA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;IAEMA,a;;;AAIJ,yBAAmBC,MAAnB,EAAmC;AAAA;;AAAA;;AAAA,mCAFH,IAEG;;AACjC,SAAKA,MAAL,GAAcA,MAAd;AACD;;;;4BAEcC,G,EAAUC,G,EAAuB;AAC9C,UAAMC,OAAO,GAAGD,GAAG,CAACE,QAAJ,CAAaH,GAAG,CAACI,SAAJ,CAAcC,EAA3B,CAAhB,CAD8C,CAE9C;;AACA,UAAMC,cAAc,GAAGC,eAAe,CAACL,OAAD,CAAtC;;AACA,UAAI,CAACI,cAAL,EAAqB;AACnB,cAAM,IAAIE,KAAJ,wCAC4B,4BAAgBN,OAAhB,CAD5B,EAAN;AAGD;;AACDF,MAAAA,GAAG,CAACI,SAAJ,CAAcC,EAAd;AACAC,MAAAA,cAAc,CAACG,OAAf,CAAuBT,GAAvB,EAA4BC,GAA5B;AACA,aAAO,CAAP;AACD;;;;;;AAGI,IAAMS,QAAQ,GAAG,SAAXA,QAAW,CAACX,MAAD;AAAA,SACtB,IAAID,aAAJ,CAAkBC,MAAlB,CADsB;AAAA,CAAjB;;;;AAGA,IAAMY,WAAW,GAAG,SAAdA,WAAc,CACzBZ,MADyB,EAEzBa,QAFyB;AAAA,SAIzB,IAAIC,mCAAJ,CAA0Bd,MAA1B,gBAAyCa,QAAzC,GAAqDE,QAArD,CAA8DF,QAA9D,CAJyB;AAAA,CAApB;;;AAMP,IAAML,eAAkD,GAAG,uBACzD,6BACM,CAAC,CAAC,IAAD,EAAO,GAAP,CAAD,EAAc,CAAC,IAAD,EAAO,GAAP,CAAd,CAAD,CAEAQ,GAFA,CAEI;AAAA;AAAA,MAAEhB,MAAF;AAAA,MAAUa,QAAV;;AAAA,SAAwBD,WAAW,CAACZ,MAAD,EAASa,QAAT,CAAnC;AAAA,CAFJ,CADL,sBAKM,CACF,CAAC,IAAD,EAAO,GAAP,CADE,EAEF,CAAC,IAAD,EAAO,GAAP,CAFE,EAGF,CAAC,IAAD,EAAO,GAAP,CAHE,EAIF,CAAC,IAAD,EAAO,GAAP,CAJE,EAKF,CAAC,IAAD,EAAO,GAAP,CALE,EAMF,CAAC,IAAD,EAAO,GAAP,CANE,EAOF,CAAC,IAAD,EAAO,GAAP,CAPE,CAAD,CASDG,GATC,CASG;AAAA;AAAA,MAAEhB,MAAF;AAAA,MAAUa,QAAV;;AAAA,SAAwB,mBAAUb,MAAV,EAAkBa,QAAlB,CAAxB;AAAA,CATH,CALL,GAeEG,GAfF,CAeM,UAACC,CAAD;AAAA,SAAoB,CAACA,CAAC,CAACjB,MAAH,EAAWiB,CAAX,CAApB;AAAA,CAfN,CADyD,CAA3D","sourcesContent":["import { Instruction, InstructionDefinition, OpCode } from \"./instructions\";\nimport { Mmu } from \"../memory/mmu\";\nimport { fromPairs } from \"lodash\";\nimport { numberToByteHex } from \"../types\";\nimport { ByteRegister } from \"./registers\";\nimport { Cpu, ClockCycles } from \"./index\";\nimport { createRlR } from \"./rl\";\n\nclass CbInstruction implements Instruction {\n  public readonly opCode: OpCode;\n  public readonly label: string = \"CB\";\n\n  public constructor(opCode: OpCode) {\n    this.opCode = opCode;\n  }\n\n  public execute(cpu: Cpu, mmu: Mmu): ClockCycles {\n    const operand = mmu.readByte(cpu.registers.pc);\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const subInstruction = CB_INSTRUCTIONS[operand];\n    if (!subInstruction) {\n      throw new Error(\n        `No instruction for CB opCode ${numberToByteHex(operand)}`\n      );\n    }\n    cpu.registers.pc++;\n    subInstruction.execute(cpu, mmu);\n    return 4;\n  }\n}\n\nexport const createCb = (opCode: OpCode): Instruction =>\n  new CbInstruction(opCode);\n\nexport const createCbBit = (\n  opCode: OpCode,\n  register: ByteRegister\n): Instruction =>\n  new InstructionDefinition(opCode, `BIT ${register}`).bitFlags(register);\n\nconst CB_INSTRUCTIONS: { [opCode: number]: Instruction } = fromPairs(\n  [\n    ...([[0x7b, \"e\"], [0x7c, \"h\"]] as ReadonlyArray<\n      [OpCode, ByteRegister]\n    >).map(([opCode, register]) => createCbBit(opCode, register)),\n\n    ...([\n      [0x17, \"a\"],\n      [0x10, \"b\"],\n      [0x11, \"c\"],\n      [0x12, \"d\"],\n      [0x13, \"e\"],\n      [0x14, \"h\"],\n      [0x15, \"l\"],\n    ] as ReadonlyArray<[OpCode, ByteRegister]>\n    ).map(([opCode, register]) => createRlR(opCode, register))\n  ].map((i: Instruction) => [i.opCode, i]),\n);\n"],"file":"cb.js"}