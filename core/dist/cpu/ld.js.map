{"version":3,"sources":["../../src/cpu/ld.ts"],"names":["createLdRR","opCode","register1","register2","InstructionDefinition","loadRegister","storeInRegister","createLdRrNn","register","loadWordOperand","createLdRN","loadByteOperand","createLdRMRr","readMemory","createLdRHlM","createLdHlMR","writeMemoryFromGroupedRegisterAddress","createLdHlMN","createLdMCA","writeMemoryFromRegisterAddress","createLdMNA","writeMemoryFromOperandAddress","createLdGrM","createLdAMNn","createLdMRA","createLdMNnA","writeByteFromWordOperandAddress","createLdMNnSp","writeWordFromProgramWord","createLddMHlA","decrementRegister","createLdiMHlA","incrementRegister"],"mappings":"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","sourcesContent":["import { ByteRegister, NonAfGroupedWordRegister } from \"./registers\";\nimport { Instruction, InstructionDefinition, OpCode } from \"./instructions\";\n\nexport const createLdRR = (\n  opCode: OpCode,\n  register1: ByteRegister,\n  register2: ByteRegister\n): Instruction =>\n  new InstructionDefinition(opCode, `LD ${register1},${register2}`)\n    .loadRegister(register2)\n    .storeInRegister(register1);\n\nexport const createLdRrNn = (\n  opCode: OpCode,\n  register: NonAfGroupedWordRegister | \"sp\"\n): Instruction =>\n  new InstructionDefinition(opCode, `LD ${register},nn`)\n    .loadWordOperand()\n    .storeInRegister(register);\n\nexport const createLdRN = (\n  opCode: OpCode,\n  register: ByteRegister\n): Instruction =>\n  new InstructionDefinition(opCode, `LD ${register},n`)\n    .loadByteOperand()\n    .storeInRegister(register);\n\nexport const createLdRMRr = (\n  opCode: OpCode,\n  register1: ByteRegister,\n  register2: NonAfGroupedWordRegister\n): Instruction =>\n  new InstructionDefinition(opCode, `LD ${register1},(${register2})`)\n    .loadRegister(register2)\n    .readMemory()\n    .storeInRegister(register1);\n\nexport const createLdRHlM = (\n  opCode: OpCode,\n  register: ByteRegister\n): Instruction =>\n  new InstructionDefinition(opCode, `LD ${register},(hl)`)\n    .loadRegister(\"hl\")\n    .readMemory()\n    .storeInRegister(register);\n\nexport const createLdHlMR = (\n  opCode: OpCode,\n  register: ByteRegister\n): Instruction =>\n  new InstructionDefinition(opCode, `LD (hl),${register}`)\n    .loadRegister(register)\n    .writeMemoryFromGroupedRegisterAddress(\"hl\");\n\nexport const createLdHlMN = (opCode: OpCode): Instruction =>\n  new InstructionDefinition(opCode, `LD (hl),n`)\n    .loadByteOperand()\n    .writeMemoryFromGroupedRegisterAddress(\"hl\");\n\nexport const createLdMCA = (opCode: OpCode): Instruction =>\n  new InstructionDefinition(opCode, `LD (0xff00+c),a`)\n    .loadRegister(\"a\")\n    .writeMemoryFromRegisterAddress(\"c\");\n\nexport const createLdMNA = (opCode: OpCode): Instruction =>\n  new InstructionDefinition(opCode, `LD (0xff00+n),a`)\n    .loadRegister(\"a\")\n    .writeMemoryFromOperandAddress();\n\nexport const createLdGrM = (\n  opCode: OpCode,\n  register: NonAfGroupedWordRegister\n): Instruction =>\n  new InstructionDefinition(opCode, `LD a,${register}`)\n    .loadRegister(register)\n    .readMemory()\n    .storeInRegister(\"a\");\n\nexport const createLdAMNn = (opCode: OpCode): Instruction =>\n  new InstructionDefinition(opCode, `LD a,(nn)`)\n    .loadWordOperand()\n    .readMemory()\n    .storeInRegister(\"a\");\n\nexport const createLdMRA = (\n  opCode: OpCode,\n  register: NonAfGroupedWordRegister\n): Instruction =>\n  new InstructionDefinition(opCode, `LD (r),a`)\n    .loadRegister(\"a\")\n    .writeMemoryFromGroupedRegisterAddress(register);\n\nexport const createLdMNnA = (opCode: OpCode): Instruction =>\n  new InstructionDefinition(opCode, `LD (nn),a`)\n    .loadRegister(\"a\")\n    .writeByteFromWordOperandAddress();\n\nexport const createLdMNnSp = (opCode: OpCode): Instruction =>\n  new InstructionDefinition(opCode, `LD (nn),sp`)\n    .loadRegister(\"sp\")\n    .writeWordFromProgramWord();\n\nexport const createLddMHlA = (opCode: OpCode): Instruction =>\n  new InstructionDefinition(opCode, `LDD (hl),a`)\n    .loadRegister(\"a\")\n    .writeMemoryFromGroupedRegisterAddress(\"hl\")\n    .decrementRegister(\"hl\");\n\nexport const createLdiMHlA = (opCode: OpCode): Instruction =>\n  new InstructionDefinition(opCode, `LDI (hl),a`)\n    .loadRegister(\"a\")\n    .writeMemoryFromGroupedRegisterAddress(\"hl\")\n    .incrementRegister(\"hl\");\n"],"file":"ld.js"}