{"version":3,"sources":["../../src/cpu/ld.ts"],"names":["createLdRR","opCode","register1","register2","InstructionDefinition","loadRegister","storeInRegister","createLdRrNn","register","loadWordOperand","createLdRN","loadByteOperand","createLdRMRr","readMemory","createLdRHlM","createLdHlMR","writeMemoryFromWordRegisterAddress","createLdHlMN","createLdMFfCA","writeMemoryFromFf00PlusRegisterAddress","createLdAMFfC","addToValue","createLdMNA","writeMemoryFromOperandAddress","createLdAMFfN","createLdGrM","createLdAMNn","createLdMRA","createLdMNnA","writeByteFromWordOperandAddress","createLdMNnSp","writeWordFromProgramWord","createLddMHlA","decrementRegister","createLdiMHlA","incrementRegister"],"mappings":"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","sourcesContent":["import { ByteRegister, NonAfGroupedWordRegister } from \"./registers\";\nimport { Instruction, InstructionDefinition, OpCode } from \"./instructions\";\n\nexport const createLdRR = (\n  opCode: OpCode,\n  register1: ByteRegister,\n  register2: ByteRegister\n): Instruction =>\n  new InstructionDefinition(opCode, `LD ${register1},${register2}`)\n    .loadRegister(register2)\n    .storeInRegister(register1);\n\nexport const createLdRrNn = (\n  opCode: OpCode,\n  register: NonAfGroupedWordRegister | \"sp\"\n): Instruction =>\n  new InstructionDefinition(opCode, `LD ${register},nn`)\n    .loadWordOperand()\n    .storeInRegister(register);\n\nexport const createLdRN = (\n  opCode: OpCode,\n  register: ByteRegister\n): Instruction =>\n  new InstructionDefinition(opCode, `LD ${register},n`)\n    .loadByteOperand()\n    .storeInRegister(register);\n\nexport const createLdRMRr = (\n  opCode: OpCode,\n  register1: ByteRegister,\n  register2: NonAfGroupedWordRegister\n): Instruction =>\n  new InstructionDefinition(opCode, `LD ${register1},(${register2})`)\n    .loadRegister(register2)\n    .readMemory()\n    .storeInRegister(register1);\n\nexport const createLdRHlM = (\n  opCode: OpCode,\n  register: ByteRegister\n): Instruction =>\n  new InstructionDefinition(opCode, `LD ${register},(hl)`)\n    .loadRegister(\"hl\")\n    .readMemory()\n    .storeInRegister(register);\n\nexport const createLdHlMR = (\n  opCode: OpCode,\n  register: ByteRegister\n): Instruction =>\n  new InstructionDefinition(opCode, `LD (hl),${register}`)\n    .loadRegister(register)\n    .writeMemoryFromWordRegisterAddress(\"hl\");\n\nexport const createLdHlMN = (opCode: OpCode): Instruction =>\n  new InstructionDefinition(opCode, `LD (hl),n`)\n    .loadByteOperand()\n    .writeMemoryFromWordRegisterAddress(\"hl\");\n\nexport const createLdMFfCA = (opCode: OpCode): Instruction =>\n  new InstructionDefinition(opCode, `LD (0xff00+c),a`)\n    .loadRegister(\"a\")\n    .writeMemoryFromFf00PlusRegisterAddress(\"c\");\n\nexport const createLdAMFfC = (opCode: OpCode): Instruction =>\n  new InstructionDefinition(opCode, `LD a,(0xff00+c)`)\n    .loadRegister(\"c\")\n    .addToValue(0xff00)\n    .readMemory()\n    .storeInRegister(\"a\");\n\nexport const createLdMNA = (opCode: OpCode): Instruction =>\n  new InstructionDefinition(opCode, `LD (0xff00+n),a`)\n    .loadRegister(\"a\")\n    .writeMemoryFromOperandAddress();\n\nexport const createLdAMFfN = (opCode: OpCode): Instruction =>\n  new InstructionDefinition(opCode, `LD a,(0xff00+n)`)\n    .loadByteOperand()\n    .addToValue(0xff00)\n    .readMemory()\n    .storeInRegister(\"a\");\n\nexport const createLdGrM = (\n  opCode: OpCode,\n  register: NonAfGroupedWordRegister\n): Instruction =>\n  new InstructionDefinition(opCode, `LD a,${register}`)\n    .loadRegister(register)\n    .readMemory()\n    .storeInRegister(\"a\");\n\nexport const createLdAMNn = (opCode: OpCode): Instruction =>\n  new InstructionDefinition(opCode, `LD a,(nn)`)\n    .loadWordOperand()\n    .readMemory()\n    .storeInRegister(\"a\");\n\nexport const createLdMRA = (\n  opCode: OpCode,\n  register: NonAfGroupedWordRegister\n): Instruction =>\n  new InstructionDefinition(opCode, `LD (r),a`)\n    .loadRegister(\"a\")\n    .writeMemoryFromWordRegisterAddress(register);\n\nexport const createLdMNnA = (opCode: OpCode): Instruction =>\n  new InstructionDefinition(opCode, `LD (nn),a`)\n    .loadRegister(\"a\")\n    .writeByteFromWordOperandAddress();\n\nexport const createLdMNnSp = (opCode: OpCode): Instruction =>\n  new InstructionDefinition(opCode, `LD (nn),sp`)\n    .loadRegister(\"sp\")\n    .writeWordFromProgramWord();\n\nexport const createLddMHlA = (opCode: OpCode): Instruction =>\n  new InstructionDefinition(opCode, `LDD (hl),a`)\n    .loadRegister(\"a\")\n    .writeMemoryFromWordRegisterAddress(\"hl\")\n    .decrementRegister(\"hl\");\n\nexport const createLdiMHlA = (opCode: OpCode): Instruction =>\n  new InstructionDefinition(opCode, `LDI (hl),a`)\n    .loadRegister(\"a\")\n    .writeMemoryFromWordRegisterAddress(\"hl\")\n    .incrementRegister(\"hl\");\n"],"file":"ld.js"}